[/
    This document is a part of Boost.Log library documentation.

    (c) 2008 Andrey Semashev

    Use, modification and distribution is subject to the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
/]

[section:utilities Utilities]

[section:string_literal String literals]

    #include <boost/log/utility/string_literal.hpp>

String literals are used in several places throughout the library. However, this component can be successfully used outside of the library in users code. It is header-only and does not require linking with the library binary. String literals can improve performance significantly if there is no need to modify stored strings. What is also important, since string literals do not dynamically allocate memory, it is easier to maintain exception safety when using string literals instead of regular strings.

The functionality is implemented in `basic_string_literal` class template, which is parametrized with character and character traits, similar to `std::basic_string`. There are also two convenience typedefs provided: `string_literal` and `wstring_literal`, for narrow and wide character types, respectively. In order to ease string literal construction in generic code there is also a `str_literal` function template that accepts a string literal and returns a `basic_string_literal` instance for the appropriate character type.

String literals support interface similar to STL strings, except for string modification functions. However, it is possible to assign to or clear string literals, as long as only string literals involved. Relational and stream output operators are also supported. A more detailed information is given in the [classref boost::log::basic_string_literal Reference section].

[endsect]

[section:type_info_wrapper Type information wrapper]

    #include <boost/log/utility/type_info_wrapper.hpp>

The language support for run time type information is essential for the library. But partially because of limitations that C++ Standard poses on this feature, partially because of differences of implementation of different compilers, there was a need for a lightweight wrapper around `std::type_info` class to fill the gaps. The table below briefly shows the differences between the `std::type_info` and `type_info_wrapper` classes.

[table Type information classes comparison
    [[Feature]                                  [`std::type_info`]              [`type_info_wrapper`]]
    [[Is default-constructable]                 [No]                            [Yes. The default-constructed wrapper is in an empty state.]]
    [[Is copy-constructable]                    [No]                            [Yes]]
    [[Is assignable]                            [No]                            [Yes]]
    [[Is swappable]                             [No]                            [Yes]]
    [[Is singleton]                             [Yes, as defined in C++ Standard. Not every compiler conforms to this requirement, though.] [No]]
    [[Life time duration]                       [Static, until the application terminates] [Dynamic]]
    [[Has an empty state]                       [No]                            [Yes. In empty state the type info wrapper is never equal to other non-empty type info wrappers. It is equal to other empty type info wrappers and can be ordered with them.]]
    [[Supports equality comparison]             [Yes]                           [Yes]]
    [[Supports ordering]                        [Yes, partial ordering with the `before` method.] [Yes, partial ordering with the complete set of comparison operators. The semantics of ordering is similar to the `std::type_info::before` method.]]
    [[Supports printable representation of type] [Yes, with `name` and `raw_name` functions.] [Yes, with `pretty_name` function. The function makes its best to print the type name in a human-readable form.]]
]

Given the distinctions above, using type information objects becomes much easier. For example, ability to copy and order with regular operators allows to use `type_info_wrapper` with containers. Ability to default-construct and assign allows to use type information as a regular objects an not to resort to pointers which may be unsafe.

[endsect]

[section:scoped_attributes Scoped attributes]

    #include <boost/log/utility/scoped_attribute.hpp>

Scoped attributes are a powerful mechanism of tagging log records that can be used for different purposes. As the naming implies, scoped attributes are registered in the beginning of a scope and unregistered on the end of the scope. The mechanism includes the following four macros:

    BOOST_LOG_SCOPED_LOGGER_ATTR(logger, attr_name, attr_type);
    BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR(logger, attr_name, attr_type, attr_ctor_args);

    BOOST_LOG_SCOPED_THREAD_ATTR(attr_name, attr_type);
    BOOST_LOG_SCOPED_THREAD_ATTR_CTOR(attr_name, attr_type, attr_ctor_args);

The former two register a source-specific attribute in the `logger` logger object. The attribute name and type are given in the `attr_name` and `attr_type` arguments. The BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR additionally accepts a __boost_preprocessor__ sequence of arguments that should be passed to the attribute constructor. The latter pair of macros do exactly the same but the attribute is registered for the current thread in the logging core (which does not require a logger).

[note If it appears that a same-named attribute is already registered in the logger/logging core, the macros won't override the existing attribute and will eventually have no effect. See [link log.rationale.why_weak_scoped_attributes Rationale] for a more detailed explanation of reasons for such behavior.]

Usage example follows:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

    void foo()
    {
        // This log record will too be marked with the "Tag" attribute, whenever it is called from the A::bar function.
        // It will not be marked when called from other places.
        BOOST_LOG(get_my_logger()) << "A log message from foo";
    }

    struct A
    {
        src::logger m_Logger;

        void bar()
        {
            // Set a thread-wide markup tag. Note the additional parenthesis to form a Boost.PP sequence.
            BOOST_LOG_SCOPED_THREAD_ATTR_CTOR("Tag", attrs::constant< std::string >, ("Called from A::bar"));

            // This log record will be marked
            BOOST_LOG(m_Logger) << "A log message from A::bar";

            foo();
        }
    };

    int main(int, char*[])
    {
        src::logger lg;

        // Let's measure our application run time
        BOOST_LOG_SCOPED_LOGGER_ATTR(lg, "RunTime", attrs::timer);

        // Mark application start. The "RunTime" attribute should be nearly 0 at this point.
        BOOST_LOG(lg) << "Application started";

        // Note that no other log records are affected by the "RunTime" attribute.
        foo();

        A a;
        a.bar();

        // Mark application ending. The "RunTime" attribute will show the execution time elapsed.
        BOOST_LOG(lg) << "Application ended";

        return 0;
    }

It is quite often convenient to mark a group of log records with a constant value in order to be able to filter the records later. The library provides two convenience macros just for this purpose:

    BOOST_LOG_SCOPED_LOGGER_TAG(logger, tag_name, tag_type, tag_value);
    BOOST_LOG_SCOPED_THREAD_TAG(tag_name, tag_type, tag_value);

The macros are effectively wrappers around `BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR` and `BOOST_LOG_SCOPED_THREAD_ATTR_CTOR`, respectively. For example, the "Tag" scoped attribute from the example above can be registered like this:

    // Note there is no "attrs::constant" type wrapping and no additional parenthesis around the tag value.
    BOOST_LOG_SCOPED_THREAD_TAG("Tag", std::string, "Called from A::bar");

[warning When using scoped attributes, make sure that the scoped attribute is not altered in the attribute set in which it was registered. For example, one should not clear or reinstall attribute set of the logger if there are logger-specific scoped attributes registered in it. Otherwise the program will likely crash. This issue is especially critical in multithreaded application, when one thread may not know whether there are scoped attributes in the logger or there are not. Future releases may solve this limitation but currently the scoped attribute must remain intact until unregistered on leaving the scope.]

Although the described macros are intended to be the primary interface for the functionality, there is also a C++ interface available. It may be useful if user decides to develop his own macros that cannot be based on the existing ones.

Any scoped attribute is attached to a generic sentry object of type `scoped_attribute`. As long as the sentry exists, the attribute is registered. There are several functions that create sentries for source or thread-specific attributes:

    // Source-specific scoped attribute registration
    template< typename LoggerT >
    [unspecified] add_scoped_logger_attribute(
        LoggerT& l, typename LoggerT::string_type const& name, shared_ptr< attribute > const& attr);

    template< typename LoggerT, typename AttributeT >
    [unspecified] add_scoped_logger_attribute(
        LoggerT& l, typename LoggerT::string_type const& name, AttributeT& attr);

    // Thread-specific scoped attribute registration
    template< typename CharT >
    [unspecified] add_scoped_thread_attribute(std::basic_string< CharT > const& name, shared_ptr< attribute > const& attr);

    template< typename CharT, typename AttributeT >
    [unspecified] add_scoped_thread_attribute(std::basic_string< CharT > const& name, AttributeT& attr);

Please note that the overloads that accept references to the attribute do not control the life time of the attribute. These overloads can be used to temporarily register attributes that reside on stack or are members of a class - in other words, whose life duration is controlled elsewhere.

The object of `scoped_attribute` type is able to attach results of each of these functions on its construction. For example, `BOOST_LOG_SCOPED_LOGGER_ATTR(lg, "RunTime", attrs::timer)` can roughly be expanded to this:

    attrs::timer attr;
    attrs::scoped_attribute sentry = attrs::add_scoped_logger_attribute(lg, "RunTime", attr);

[endsect]

[section:rotating_ofstream Rotating file stream]

    #include <boost/log/utility/rotating_ofstream.hpp>

It is often convenient to split log into several parts in order to reduce log file sizes and make it more manageable. This functionality is implemented in the `basic_rotating_ofstream` class template (convenience typedefs `rotating_ofstream` and `rotating_wofstream` are also available). This stream is capable to dynamically change the underlying file the data written to. There are two supported criteria of rotation:

* The file can be rotated upon a certain file size. The maximum file size can be specified in the stream constructor or `open` method in the named argument `rotation_size`.

[note The rotation file size can be imprecise. The implementation counts the number of bytes written to the file, but the underlying API can introduce additional auxiliary data, which would increase the log file size on disk. The most well-known such case is the way Windows and DOS operating systems work with text files with regard to new-line characters. Each new-line character is written as a two byte sequence 0x0D 0x0A instead of a single 0x0A. There are other platforms known that introduce much more distortion into the written data.]

* The file can be rotated upon some time interval, which can be specified in the named argument `rotation_interval` as number of seconds.

These two criteria can be combined together, so it is possible, for instance, to rotate the log file each hour but keep its size under 1 MB.

Since the underlying file may change, the rotating stream accepts a file name template instead of the final file name. The file name may be composed of the current date and time (see formatting capabilities of __boost_date_time__ for placeholder description) and/or file counter (using the `%N` placeholder with optional `printf`-style format specifiers). A few quick examples:

[table
    [[Template]                            [Expands to]]
    [[file\_%N.log]                        [file\_1.log, file\_2.log...]]
    [[file\_%03N.log]                      [file\_001.log, file\_002.log...]]
    [[file\_%Y%m%d.log]                    [file\_20080705.log, file\_20080706.log...]]
    [[file\_%Y-%m-%d\_%H-%M-%S.%N.log]     [file\_2008-07-05\_13-44-23.1.log, file\_2008-07-06\_16-00-10.2.log...]]
]

The rotating stream is designed in order not to break log records in the middle when it comes to rotating the file. This feature needs the stream to know when a log record is ended and when the next one is started. Such requirement cannot be fulfilled with the standard stream interface. The `basic_rotating_ofstream` supports an additional interface `record_writer` that allows the stream to receive such metadata. However, this makes [_the rotating stream not a regular stream anymore, since it doesn't write data into the underlying file until it receives notifications that delimit log records]. The `record_writer` interface is also supported in the [link log.detailed.sink_backends.text_ostream text stream backend], so using the rotating stream with the sink just works. But if you ever use the rotating stream outside the library, you should make sure you provide the stream with this metadata.

Here's a basic usage example:

    void foo()
    {
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(
            new sinks::synchronous_sink< sinks::text_ostream_backend >);

        // The file will rotate every hour and will attempt not to exceed 1 MB.
        sink->locked_backend()->add_stream(boost::make_shared< rotating_ofstream >(
            "file_%02N.log", keywords::rotation_interval = 3600, keywords::rotation_size = 1048576));

        logging::core::get()->add_sink(sink);
    }

But there's more about the rotating file stream. The stream also supports calling user-defined functions before closing and after opening the underlying file. This can be very useful when the file should have a header and/or footer, like XML files, for example. With support of formatters, it is well possible to store log records in XML, like this:

    // The function is called for every file being opened
    void write_header(std::ostream& strm)
    {
        strm << "<?xml version=\"1.0\"?>\n"
                "<log>\n";
    }

    // The function is called for every file being closed
    void write_footer(std::ostream& strm)
    {
        strm << "</log>\n";
    }

    void foo()
    {
        // Construct the stream
        boost::shared_ptr< rotating_ofstream > strm(
            new rotating_ofstream("log_%02N.xml", keywords::rotation_interval = 3600, keywords::rotation_size = 1048576));

        // Setup open and close handlers
        strm->set_open_handler(&write_header);
        strm->set_close_handler(&write_footer);

        // Create a sink
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(
            new sinks::synchronous_sink< sinks::text_ostream_backend >);
        sink->locked_backend()->add_stream(strm);

        // Setup the formatter
        sink->locked_backend()->set_formatter(fmt::stream
            << "\t<message id=\"" << fmt::attr< unsigned int >("Line #") << "\">\n"
                << "\t\t<timestamp>" << fmt::date_time("TimeStamp") << "</timestamp>\n"
                << "\t\t<level>" << fmt::attr< int >("Severity") << "</level>\n"
                << "\t\t<![CDATA[" << fmt::message() << "]]>\n"
            << "\t</message>");

        logging::core::get()->add_sink(sink);
    }

[endsect]

[section:type_dispatch Type dispatchers]

    #include <boost/log/utility/type_dispatch/type_dispatcher.hpp>

Type dispatchers are used throughout the library in order to work with attribute values. Dispatchers allow to acquire actual typed attribute value using the Visitor concept. The most notable places where the functionality is used are filters and formatters. However, this mechanism is orthogonal to attributes and can be used for other purposes as well. Most of the time users won't need to dig into details of type dispatchers, but this information may be useful for the ones who intend to extend the library and wants to understand what's under the hood.

Every type dispatcher supports `type_dispatcher` interface. When an attribute value needs to be extracted, this interface is passed to the attribute value object, which then tries to acquire the concrete visitor for the actual type of the value. All visitors derive from the appropriate instance of the `type_visitor` class template, instantiated on the actual type of the value. If the dispatcher is capable to consume the value of the requested type, it must return the pointer to the appropriate visitor interface. Otherwise it returns `NULL`. When (and if) the corresponding visitor is acquired, the attribute value object only have to pass the contained value to the visitor.

Gladly, there is no need to write type dispatchers from scratch. The library provides two kinds of type dispatchers that implement `type_dispatcher` and `type_visitor` interfaces and encapsulate the visitor lookup.

[heading Static type dispatcher]

    #include <boost/log/utility/type_dispatch/static_type_dispatcher.hpp>

Static type dispatchers are used when the set of types that needs to be supported for extraction is known at compile time. The `static_type_dispatcher` class template is parametrized with an MPL type sequence of types that needs to be supported. The dispatcher inherits from `type_dispatcher` and `type_visitor` instances for all types in the MPL sequence. All you need to do is derive your class from the dispatcher and implement the `visit` methods for all supported types, like this:

    // A simple attribute value
    template< typename T >
    struct my_value :
        public logging::attribute_value
    {
        T m_Value;

        explicit my_value(T const& value) : m_Value(value) {}

        // The function passes the contained type into the dispatcher
        bool dispatch(logging::type_dispatcher& dispatcher)
        {
            logging::type_visitor< T >* visitor = dispatcher.get_visitor< T >();
            if (visitor)
            {
                visitor->visit(m_Value);
                return true;
            }
            else
                return false;
        }

        // Other functions omitted for brevity...
    };

    // Type dispatcher for the supported types
    struct my_dispatcher :
        public logging::static_type_dispatcher<
            boost::mpl::vector< int, double, std::string >
        >
    {
        // Implement visitation logic for all supported types
        void visit(int const& value)
        {
            std::cout << "Received int value = " << value << std::endl;
        }
        void visit(double const& value)
        {
            std::cout << "Received double value = " << value << std::endl;
        }
        void visit(std::string const& value)
        {
            std::cout << "Received string value = " << value << std::endl;
        }
    };

    int main(int, char*[])
    {
        my_dispatcher disp;

        // These two attributes are supported by the dispatcher
        my_value< std::string > val1("Hello world!");
        assert(val1.dispatch(disp));

        my_value< double > val2(1.2);
        assert(val2.dispatch(disp));

        // This one is not
        my_value< float > val3(-4.3);
        assert(!val3.dispatch(disp));

        return 0;
    }

[tip In the example above we implemented a reduced attribute value object. Since in most cases this implementation is always the same, the library provides a ready-to-go attribute value in the [headerref boost/log/attributes/basic_attribute_value.hpp ] file, the `basic_attribute_value` class template.]

Static type dispatcher also supports another way of use which allows to avoid code duplication if values of several types have to be processed in a similar manner. In the example above we wanted to print the dispatched value on the console, whatever it is. The same can be achieved with templated metafunction class which is injected into the dispatcher as a visitor.

    // The templated visitor will be instantiated on every type supported by the dispatcher
    template< typename T >
    struct my_visitor :
        public logging::type_visitor< T >
    {
        void visit(T const& value)
        {
            std::cout << "Received " << typeid(T).name() << " value = " << value << std::endl;
        }
    };

    // Type dispatcher for the supported types
    typedef logging::static_type_dispatcher<
        boost::mpl::vector< int, double, std::string >,
        boost::mpl::quote1< my_visitor >
    > my_dispatcher;

This dispatcher can be used precisely the same way as the previously defined one. Note also that __boost_mpl__ lambda expressions are also supported as visitor generators.

[tip See also [link log.detailed.utilities.extractors attribute value extractors] for an even simpler solution if all you want is to get an attribute value.]

[heading Dynamic type dispatcher]

    #include <boost/log/utility/type_dispatch/dynamic_type_dispatcher.hpp>

In case if the set of types that have to be supported is not available at compile time, the `dynamic_type_dispatcher` class to help. One can use its `register_type` method to add support for a particular type. User has to pass a function object along with the type, this functor will be called when a visitor for the specified type is invoked. Considering the `my_value` from the code sample for static type dispatcher is intact, the code can be rewritten as follows:

    // Implement visitation logic for all supported types
    void on_int(int const& value)
    {
        std::cout << "Received int value = " << value << std::endl;
    }
    void on_double(double const& value)
    {
        std::cout << "Received double value = " << value << std::endl;
    }
    void on_string(std::string const& value)
    {
        std::cout << "Received string value = " << value << std::endl;
    }

    int main(int, char*[])
    {
        logging::dynamic_type_dispatcher disp;

        // Register type visitors
        disp.register_type< int >(&on_int);
        disp.register_type< double >(&on_double);
        disp.register_type< std::string >(&on_string);

        // These two attributes are supported by the dispatcher
        my_value< std::string > val1("Hello world!");
        assert(val1.dispatch(disp));

        my_value< double > val2(1.2);
        assert(val2.dispatch(disp));

        // This one is not
        my_value< float > val3(-4.3);
        assert(!val3.dispatch(disp));

        return 0;
    }

Of course, complex function objects, like provided by __boost_bind__, are also supported.

[endsect]

[section:predef_types Predefined type sequences]

    #include <boost/log/utility/type_dispatch/standard_types.hpp>
    #include <boost/log/utility/type_dispatch/date_time_types.hpp>

One may notice that when using type dispatchers and defining filters and formatters it may be convenient to have some predefined type sequences to designate frequently used sets of types. The library provides several such sets.

[table Standard types (standard_types.hpp)
    [[Type sequence]                            [Meaning]]
    [[`integral_types`]                         [All integral types, including `bool`, character and 64 bit integral types, if available]]
    [[`floating_point_types`]                   [Floating point types]]
    [[`numeric_types`]                          [Includes `integral_types` and `floating_point_types`]]
    [[`string_types` and `wstring_types`]       [Narrow or wide string types. Currently only includes STL string types and [link log.detailed.utilities.string_literal string literals].]]
]

There are also a number of time-related type sequences available:

[table Time-related types (date_time_types.hpp)
    [[Type sequence]                            [Meaning]]
    [[`native_date_time_types`]                 [All types defined in C/C++ standard that have both date and time portions]]
    [[`boost_date_time_types`]                  [All types defined in __boost_date_time__ that have both date and time portions]]
    [[`date_time_types`]                        [Includes `native_date_time_types` and `boost_date_time_types`]]
    [[`native_date_types`]                      [All types defined in C/C++ standard that have date portion. Currently equivalent to `native_date_time_types`.]]
    [[`boost_date_types`]                       [All types defined in __boost_date_time__ that have date portion]]
    [[`date_types`]                             [Includes `native_date_types` and `boost_date_types`]]
    [[`native_time_types`]                      [All types defined in C/C++ standard that have time portion. Currently equivalent to `native_date_time_types`.]]
    [[`boost_time_types`]                       [All types defined in __boost_date_time__ that have time portion. Currently equivalent to `boost_date_time_types`.]]
    [[`time_types`]                             [Includes `native_time_types` and `boost_time_types`]]
    [[`native_time_duration_types`]             [All types defined in C/C++ standard that are used to represent time duration. Currently only includes `double`, as the result type of the `difftime` standard function.]]
    [[`boost_time_duration_types`]              [All time duration types defined in __boost_date_time__]]
    [[`time_duration_types`]                    [Includes `native_time_duration_types` and `boost_time_duration_types`]]
    [[`boost_time_period_types`]                [All time period types defined in __boost_date_time__]]
    [[`time_period_types`]                      [Currently equivalent to `boost_time_period_types`]]
]

[endsect]

[section:extractors Attribute value extractors]

    #include <boost/log/utility/attribute_value_extractor.hpp>

Attribute value extractors serve as a helper tool on top of [link log.detailed.utilities.type_dispatch type dispatchers] in order to simplify extracting attribute values in generic code. The functionality is implemented in the `attribute_value_extractor` class template, parametrized on character type and type or MPL sequence of types that have to be supported for dispatch. The `attribute_value_extractor` instance is a binary functional object that accepts a set of attribute values and another functional object that will receive the extracted attribute value. The name of the attribute to be extracted is given as the constructor argument to the extractor. The key advantage of using extractors instead of raw dispatchers is that the receiving functional object may have a template `operator ()`. Obviously, this allows to reduce the amount of code in case of similar processing of attributes of different types. For example:

    // A generic function object that outputs attribute value
    struct print_attribute_value
    {
        typedef void result_type;

        // This operator will be instantiated for all possible types of the attribute value
        template< typename T >
        void operator() (T const& value) const
        {
            std::cout << "Received " << logging::type_info_wrapper(typeid(T)).pretty_name()
                << " attribute value: " << value << std::endl;
        }
    };

    void foo(attribute_values_view const& attrs)
    {
        // Let's assume we want to output value of attribute "MyAttr" that may have any numeric type
        logging::attribute_value_extractor< char, logging::numeric_types > extractor1("MyAttr");
        assert(extractor1(attrs, print_attribute_value()));

        // The extractor returns false if it is unable to extract the value
        logging::attribute_value_extractor< char, std::complex< double > > extractor2("MyAttr");
        assert(!extractor2(attrs, print_attribute_value()));
    }

Note that predefined type sequences provided by the library can be used freely with extractors just as well as with filters and formatters. Also note that specifying a single type of the attribute value instead of type sequence is also perfectly valid.

The library also provides an `extract` convenience function that automatically creates extractor object. The `foo` function from the example above can be rewritten like this:

    void foo(attribute_values_view const& attrs)
    {
        assert(extract< logging::numeric_types >("MyAttr", attrs, print_attribute_value()));
        assert(!extract< std::complex< double > >("MyAttr", attrs, print_attribute_value()));
    }

[endsect]

[section:record_ordering Log record ordering]

    #include <boost/log/utility/record_ordering.hpp>

There are cases when it is required to order log records between each other. One possible use case is storing records in a container or a priority queue. The library provides two types of record ordering predicates out of box:

[heading Opaque handle ordering]

The `handle_ordering` class allows to apply a quick opaque ordering. The result of this ordering is not stable between different runs of the application, however it provides the best performance. The `handle_ordering` is a template that is specialized with an optional predicate function that will be able to compare `void*` pointers. By default an `std::less` equivalent is used.

    // A set of unique records
    std::set< logging::record, logging::handle_ordering< > > m_Records;

[heading Attribute value based ordering]

This kind of ordering is implemented with the `attribute_value_ordering` class and is based on the attribute values attached to the record. The predicate will seek for an attribute value with the specified name in both records being ordered and attempt to compare the attribute values.

    // Ordering type definition
    typedef logging::attribute_value_ordering<
        char,   // character type that is used by Boost.Log
        int     // attribute value type
    > ordering;

    // Records organized into a queue based on the "Severity" attribute value
    std::priority_queue<
        logging::record,
        std::vector< logging::record >,
        ordering
    > m_Records(ordering("Severity"));

Like the `handle_ordering`, `attribute_value_ordering` also accepts the third optional template parameter, which should be the predicate capable to compare attribute values (`int`s in the example above). By default, an `std::less` equivalent is used.

You may also use the `make_attr_ordering` generator function to automatically generate the `attribute_value_ordering` instance based on the attribute value name and the ordering function. This might be useful if ordering function has a non-trivial type, like the one __boost_bind__ provides.

[endsect]


[section:init Simplified library initialization tools]

This part of the library is provided in order to simplify logging initialization and provide basic tools to develop user-specific initialization mechanisms. It is known that setup capabilities and preferences may vary widely from application to application, therefore the library does not attempt to provide a universal solution for this task. The provided tools are mostly intended to serve as a quick drop-in support for logging setup and a set of instruments to implement something more elaborate and more fitting user's needs.

[section:convenience Convenience functions]

    #include <boost/log/utility/init/to_console.hpp>
    #include <boost/log/utility/init/to_file.hpp>
    #include <boost/log/utility/init/common_attributes.hpp>

The library provides a number of functions that simplify some common initialization procedures, like sink and commonly used attributes registration. This is not much of a functionality, however, it allows to save a couple of minutes of learning the library for a newcomer.

Logging to the application console is the simplest way to see the logging library in action. To achieve this, one can initialize the library with a single function call, like this:

    int main(int, char*[])
    {
        // Initialize logging to std::clog
        logging::init_log_to_console();

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Pretty easy, isn't it? There is `winit_log_to_console` function for wide-character logging. If you want to put logs to some other standard stream, you can pass the stream to the `init_log_to_console` function as an argument. E.g. enabling logging to `std::cout` instead of `std::clog` would look like this:

    logging::init_log_to_console(std::cout);

What's important, is that you can further manage the console sink if you save the `shared_ptr` to the sink that this function returns. This allows you to setup things like filter, formatter and auto-flush flag.

    int main(int, char*[])
    {
        // Initialize logging to std::clog
        boost::shared_ptr<
            sinks::synchronous_sink< sinks::text_ostream_backend >
        > sink = logging::init_log_to_console();

        sink->set_filter(flt::attr< int >("Severity") >= 3);
        sink->locked_backend()->auto_flush(true);

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Similarly to console, one can use a single function call to enable logging to a file. All you have to do is to provide the file name:

    int main(int, char*[])
    {
        // Initialize logging to the "test.log" file
        logging::init_log_to_file("test.log");

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Like with `init_log_to_console`, the `init_log_to_file` function has its wide-character counterpart `winit_log_to_file` and returns the `shared_ptr` to the registered sink. The functions do not conflict and may be combined freely, so it is possible to setup logging to console and a couple of files, including filtering and formatting, in about 10 lines of code.

Lastly, there is a `add_common_attributes` function that registers two most frequently used attributes: "LineID" and "TimeStamp". The former counts log record being made and has attribute value `unsigned int`. The latter, as its name implies, provides current time for each log record, in form of `boost::posix_time::ptime` (see __boost_date_time__). These two attributes are registered globally, so they will remain available in all threads and loggers. This makes the final version of our code sample to look something like this:

    int main(int, char*[])
    {
        // Initialize sinks
        logging::init_log_to_console()->set_filter(flt::attr< int >("Severity") >= 4);

        boost::function< void (std::ostream&, attribute_values_view const&, std::string const&) > formatter =
            fmt::stream
                << fmt::attr< unsigned int >("LineID", "[% 9u] ")
                << fmt::date_time< boost::posix_time::ptime >("TimeStamp") << " *"
                << fmt::attr< int >("Severity") << "* " << fmt::message();

        logging::init_log_to_file("complete.log")->locked_backend()->set_formatter(formatter);

        boost::shared_ptr<
            sinks::synchronous_sink< sinks::text_ostream_backend >
        > sink = logging::init_log_to_file("essential.log");
        sink->locked_backend()->set_formatter(formatter);
        sink->set_filter(flt::attr< int >("Severity") >= 1);

        // Register common attributes
        logging::add_common_attributes();

        // Here we go, we can write logs
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

[endsect]

[section:filter_formatter Filter and formatter parsers]

    #include <boost/log/utility/init/filter_parser.hpp>
    #include <boost/log/utility/init/formatter_parser.hpp>

Filter and formatter parsers allow to construct filters and formatters from a descriptive string. The function `parse_filter` is responsible for recognizing filters and `parse_formatter` - for recognizing formatters.

In case of filters the string is formed of a sequence of condition expressions, interconnected with boolean operations. There are two operations supported: conjunction (designated as "&" or "and") and disjunction ("|" or "or"). Each condition itself may be either a single condition or a sub-filter, taken in round brackets. Each condition can be negated with the "!" sign or "not" keyword. The condition, if it's not a sub-filter, usually consists of an attribute name enclosed in percent characters ("%"), a relation keyword and an operand. The relation and operand may be omitted, in which case the condition is assumed to be the requirement of the attribute presence (with any type).

[pre
filter:
    condition { op condition }

op:
    &
    and
    |
    or

condition:
    !condition
    not condition
    (filter)
    %attribute_name%
    %attribute_name% relation operand

relation:
    >
    <
    =
    !=
    >=
    <=
    begins_with
    ends_with
    contains
    matches
]

Below are some examples of filters:

[table Examples of filters
[[Filter string]                    [Description]]
[[`%Severity%`]                     [The filter returns `true` if an attribute value with name "Severity" is found in a log record.]]
[[`%Severity% > 3`]                 [The filter returns `true` if an attribute value with name "Severity" is found and it is greater than 3. The attribute value must be of one of the [link log.detailed.utilities.predef_types integral types].]]
[[!(`%Ratio% > 0.0 & %Ratio% <= 0.5)`] [The filter returns `true` if an attribute value with name "Ratio" of one of the [link log.detailed.utilities.predef_types floating point types] is not found or it is not between 0 and 0.5.]]
[[`%Tag% contains "net" or %Tag% contains "io" and not %StatFlow%`] [The filter returns `true` if an attribute value with name "Tag" is found and contains words "net" or "io" and if an attribute value "StatFlow" is not found. The "Tag" attribute value must be of one of the [link log.detailed.utilities.predef_types string types], the "StatFlow" attribute value type is not considered.]]
]

The formatter string syntax is even simpler and pretty much resembles __boost_format__ format string syntax. The string must contain attribute names enclosed in percent signs ("%"), the corresponding attribute value will replace these placeholders. The placeholder "%\_%" is special, it will be replaced with the log record text. For instance, `[%TimeStamp%] *%Severity%* %_%` formatter string will make log records look like this: `[2008-07-05 13:44:23] *0* Hello world`.

It must be noted, though, that by default the library only supports those attribute value types [link log.detailed.utilities.predef_types which are known] at the library build time. User-defined types will not work properly in parsed filters and formatters until registered in the library. More on this is available in the [link log.extension.settings Extending the library] section.

[note The parsed formatters and filters are generally less optimal than the equivalent ones written in code. This is because of two reasons: (\*) the programmer usually knows more about types of the attribute values that may be involved in formatting or filtering and (\*) the compiler has a better chance to optimize the formatter or filter if it is known in compile time. Therefore, if the performance matters, it is advised to avoid parsed filters and formatters.]

[endsect]

[section:settings Library initialization from a settings file]

    #include <boost/log/utility/init/from_stream.hpp>

Support for configuration files is a frequently requested feature of the library. And despite the fact there is no ultimately convenient and flexible format of the library settings, the library supports this feature. The functionality is implemented with a simple function `init_from_stream`, which accepts an STL input stream and reads the library settings from it.

The settings format is quite simple and widely used. Below is the description of syntax and parameters.

[pre
\# Comments are allowed. Comment line begins with the '\#' character and spans until the end of the line.

\# Logging core settings section. May be omitted if no parameters specified within it.
\[Core\]

\# Enables or disables logging completely. May have values 0 or 1. Optional, default value is 0.
DisableLogging\=0

\# Global filter. Optional, by default no filter is applied.
Filter\="%Severity% > 3"


\# Sink settings sections. There may be arbitrary number of such sections. It is essential that the sink section name
\# begins with the "Sink:" prefix. The rest of the section name is not relevant and is used for convenience and making
\# section names unique.
\[Sink:MySink1\]

\# Sink destination type. Mandatory, can have one of the following values: Console, TextFile, Syslog, SimpleEventLog, Debugger.
\# Destinations except for Console and TextFile may not be supported on all platforms.
Destination\=Console

\# Sink-specific filter. Optional, by default no filter is applied.
Filter\="%Target% contains "MySink1""

\# Formatter string. Optional, by default only log record message text is written.
Format\="<%TimeStamp%> - %\_%"

\# The flag shows whether the sink should be asynchronous. May have values 0 or 1. Optional, default value is 0.
\# Not used in single-threaded builds.
Asynchronous\=0

\# Specific for Console and TextFile sinks. Enables automatic stream flush after each log record.
\# May have values 0 or 1. Optional, default value is 0.
AutoFlush\=0

\# Specific for TextFile sink. Log file name or name template. Mandatory.
FileName\="test\_%N%.log"

\# Specific for TextFile sink. Log file rotation size, in bytes. Optional, by default no rotation on size is performed.
RotationSize\=65536

\# Specific for TextFile sink. Log file rotation interval, in seconds. Optional, by default no rotation on time interval is performed.
RotationInterval\=3600
]

Here's the usage example:

    int main(int, char*[])
    {
        // Read logging settings from a file
        std::ifstream file("settings.ini");
        logging::init_from_stream(file);

        return 0;
    }

The settings parser also allows to be extended to support custom sink types. See the [link log.extension.settings Extending the library] section for more information.

[endsect]

[endsect]

[endsect]
