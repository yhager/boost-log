[/
    This document is a part of Boost.Log library documentation.

    (c) 2008 Andrey Semashev

    Use, modification and distribution is subject to the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
/]

[section:advanced Detailed features description]

This section contains a more detailed description of library components and features. Some of them are presented in the [link tutorial.tutorial Tutorial] section, so it is recommended to read it first to get the basic understanding of the library.

[section:sources Logging sources]

[section:basic_logger Basic loggers]

    #include <boost/log/sources/basic_logger.hpp>

The simplest logging sources provided by the library are loggers `logger` and its thread-safe version, `logger_mt` (`wlogger` and `wlogger_mt` for wide-character logging, accordingly). These loggers only provide an ability to store source-specific attributes within themselves and, of course, to form log records. This type of loggers should probably be used in case if there is no need in advanced features like severity level checks. It may well be used as a tool to collect application statistics and register application events, such as notifications and alarms. In such cases the logger is normally used in conjunction with [link advanced.advanced.utilities.scoped_attributes scoped attributes] to attach the needed data to the notification event. Below is an example of usage:

    class network_connection
    {
        src::logger m_logger;
        src::logger::attribute_set_type::iterator m_remote_addr;

    public:
        void on_connected(std::string const& remote_addr)
        {
            // Put the remote address into the logger to automatically attach it to every log record written through the logger
            m_remote_addr = m_logger.add_attribute("RemoteAddress",
                boost::make_shared< attr::constant< std::string > >(remote_addr)).first;

            // The straightforward way of logging
            if (m_logger.open_record())                         // check the filters
                m_logger.strm() << "Connection established";    // format the record
        }
        void on_disconnected()
        {
            // The simpler way of logging: the above "if" condition is wrapped into a neat macro
            BOOST_LOG(m_logger) << "Connection shut down";

            // Remove the attribute with the remote address
            m_logger.remove_attribute(m_remote_addr);
        }
        void on_data_received(std::size_t size)
        {
            // Put the size as an additional attribute so it can be collected and accumulated later if needed
            // The attribute will be attached to the only log record that is made within the current scope
            BOOST_LOG_SCOPED_LOGGER_TAG(m_logger, "ReceivedSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_logger) << "Some data received";
        }
        void on_data_sent(std::size_t size)
        {
            BOOST_LOG_SCOPED_LOGGER_TAG(m_logger, "SentSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_logger) << "Some data sent";
        }
    };

Class `network_connection` in the code snippet above represents an approach of implementing simple logging and statistic information gathering in a network-related application. Each of the presented methods of the class effectively marks a corresponding event that may be tracked and collected on sinks level. Furthermore, other methods of the class, that are not shown here for simplicity, are able to write logs too. Note that every log record ever made in the connected state of the `network_connection` object will be implicitly marked up with an address of the remote site.

[endsect]

[section:severity_level_logger Loggers with severity level support]

    #include <boost/log/sources/severity_logger.hpp>

An ability to distinguish some log records from others based on some kind of level of severity or importance is one of the most frequently requested feature. The class templates `severity_logger` and `severity_logger_mt` (along with their `wseverity_logger` and `wseverity_logger_mt` wide-char counterparts) provide this functionality.

The loggers automatically register a special source-specific attribute "Severity", which can be set for every record in a compact and efficient manner, with a named argument `severity` that can be passed to the constructor and/or the `open_record` method. If passed to the logger constructor, the `severity` argument sets the default value of the severity level that will be used if none provided in the `open_record` arguments. The `severity` argument passed to the `open_record` method sets the level of the particular log record being made. The type of the severity level can be provided as a template argument for the logger class template. The default type is `int`.

The actual values of this attribute and their meaning is entirely user-defined. However, it is recommended to use level of value equivalent to zero as a base point for other values. This is because the default-constructed logger object sets default severity level to zero. It is also recommended to define the same levels of severity for the entire application in order to avoid the confusion in the written logs later. The following code snippet shows the usage of `severity_logger`.

    // User-defined severity levels
    enum my_levels
    {
        normal,
        warning,
        error
    };

    void foo()
    {
        // The default-constructed logger will use default level 0. The level type is int.
        src::severity_logger< > lg;

        // The straightforward usage with default severity level (which is 0)
        if (lg.open_record())
            lg.strm() << "A default-severity log record";

        // The straightforward usage with a specific level value
        if (lg.open_record(src::keywords::severity = warning))
            lg.strm() << "A warning level log record";

        // The default severity can be specified in constructor. This time level type is my_levels.
        src::severity_logger< my_levels > error_lg(src::keywords::severity = error);

        // There are predefined macros that make the usage easier
        BOOST_LOG_SEV(lg, warning) << "A warning level log record";

        // Thanks to the default severity level, you can use the basic macros too
        BOOST_LOG(error_lg) << "An error level log record";
    }

And, of course, severity loggers also provide the same functionality the [link advanced.advanced.sources.basic_logger basic loggers] do.

[endsect]

[section:channel_logger Loggers with channel support]

    #include <boost/log/sources/channel_logger.hpp>

Sometimes it is important to categorize log records based on some constant piece information, such as module or class name, relation of the logged information to some specific domain of application functionality (e.g. network or file system related messages) or some constant tag that may be used later to filter these records to a specific sink. This feature is fulfilled with loggers `channel_logger`, `channel_logger_mt` and their wide-char counterparts `wchannel_logger`, `wchannel_logger_mt`. These loggers automatically register an attribute named "Channel". This attribute can be set only in the logger constructor with a named argument `channel` and cannot be changed during the logger lifetime. The type of the channel attribute value can be specified as a template argument for the logger, with `std::string` (`std::wstring` in case of wide character loggers) as a default. Aside from that the usage is similar to the [link advanced.advanced.sources.basic_logger basic loggers]:

    class network_connection
    {
        src::channel_logger< > m_net;
        src::channel_logger< > m_stat;
        src::logger::attribute_set_type::iterator m_remote_addr;

    public:
        network_connection() :
            // We can dump network-related messages through this logger and be able to filter them later
            m_net(src::keywords::channel = "net"),
            // We also can separate statistic records in a different channel in order to route them to a different sink
            m_stat(src::keywords::channel = "stat")
        {
        }

        void on_connected(std::string const& remote_addr)
        {
            // Put message to the "net" channel
            BOOST_LOG(m_net) << "Connection established";
        }
        void on_disconnected()
        {
            // Put message to the "net" channel
            BOOST_LOG(m_net) << "Connection shut down";
        }
        void on_data_received(std::size_t size)
        {
            // Put the size as an additional attribute so it can be collected and accumulated later if needed
            // The attribute will be attached to the only log record that is made within the current scope
            BOOST_LOG_SCOPED_LOGGER_TAG(m_stat, "ReceivedSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_stat) << "Some data received";
        }
        void on_data_sent(std::size_t size)
        {
            BOOST_LOG_SCOPED_LOGGER_TAG(m_stat, "SentSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_stat) << "Some data sent";
        }
    };

[endsect]

[section:mixed_loggers Loggers with mixed features]

    #include <boost/log/sources/severity_channel_logger.hpp>

If you wonder whether you can use a mixed set of several logger features in one logger, then yes, you certainly can. The library provides `severity_channel_logger` and `severity_channel_logger_mt` (with their wide-char analogues `wseverity_channel_logger` and `wseverity_channel_logger_mt`) which combine features of the described loggers with [link advanced.advanced.sources.severity_level_logger severity level] and [link advanced.advanced.sources.channel_logger channels] support. The composite loggers are templates, too, which allows you to specify severity level and channel types. You can also design your own logger features and combine them with the ones provided by the library[/, as described in the [link extension.extension.sources Extending the library] section/].

[endsect]

[section:global_storage Global storage for loggers]

    #include <boost/log/sources/global_logger_storage.hpp>

Sometimes it is inconvenient to have a logger object to be able to write logs. This issue is often present in a functional-style code with no obvious places where a logger could be stored. An other domain where the problem persists is generic libraries that want to support logging. In such cases it would be more convenient to have one or several global loggers in order to easily access them in every place when needed. In this regard `std::cout` is a good example of such a logger.

The library provides a way to declare global loggers that can be accessed pretty much like `std::cout`. In fact, this feature can be used with any loggers, including user-defined ones. Having declared a global logger, one can be sure to have a thread-safe access to this logger instance from any place of the application code. The library also guarantees that a global logger instance will be singular even across module boundaries. This allows to employ logging even in header-only components that may be compiled into different modules.

One may wonder why there is need for something special in order to create global loggers. Why not just declaring a logger variable in the namespace scope and use it wherever you need? While technically this is possible, declaring and using global logger variables is complicated for the following reasons:

* Order of initialization of the namespace scope variables is not specified by the C++ Standard. It means that generally you cannot use the logger during this stage of initialization (i.e. before `main`).
* Initialization of the namespace scope variables is not thread-safe. You may end up initializing the same logger twice or using an uninitialized logger.
* Using namespace scope variables in a header-only library is quite complicated. One either has to declare a variable with external linkage and define it only in a single translation unit (that is, in a separate .cpp file, which defeats the "header-only" thesis), or define a variable with internal linkage, or as a special case in an anonymous namespace (this will most likely break ODR and give unexpected results when the header is used in different TUs). There are other compiler-specific and standard tricks to tackle the problem, but they are not too trivial and portable.
* On most platforms namespace scope variables are local to the module where they were compiled in. That is, if variable `a` has external linkage and was compiled into modules X and Y, each of these modules have its independent copy of variable `a`. To make things worse, on other platforms this variable may get shared between the modules.

Global logger storage is intended to eliminate all these problems.

The easiest way to declare a global logger is to use the following macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::severity_logger_mt< >)

The `my_logger` argument gives the logger a name that may be used to acquire the logger instance. The second parameter denotes the logger type. In multithreaded applications, when the logger can be accessed from different threads, users will normally want to use thread-safe versions of loggers.

In case if there is a need to pass arguments to the logger constructor, there is another macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS(
        my_logger,
        src::severity_channel_logger< >,
        (src::keywords::severity = error)(src::keywords::channel = "my_channel"))

The last macro argument is a __boost_preprocessor__ sequence of arguments passed to the logger constructor. Be careful, however, when using non-constant expressions and references to objects as constructor arguments, since the arguments are evaluated only once and it is often difficult to tell the exact moment when it is done. The logger is constructed on the first request from whichever part of the application that has the knowledge of the logger declaration. It is up to user to make sure that all arguments have valid states at that point.

The third macro of this section provides maximum flexibility, allowing user to actually define the logic of creating the logger.

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::severity_logger_mt)
    {
        // Do something that needs to be done on logger initialization, e.g. add a stop watch attribute
        src::severity_logger_mt< > lg;
        lg.add_attribute("StopWatch", boost::make_shared< attrs::timer >());
        // The initializing routine must return the logger instance
        return lg;
    }

Like the `BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS` macro, the initializing code is called only once, on the first request of the logger.

[important Beware of the One Definition Rule (ODR) violation issues. Regardless of the way of logger declaration you choose, you should ensure that [_the logger is declared in exactly the same way at all occurrences] and [_all symbol names involved in the declaration resolve to the same entities]. The latter includes the names used within the initialization routine of the `BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT` macro, such as references to external variables, functions and types. The library tries to protect itself from ODR violations to a certain degree, but in general the behavior is undefined if the rule is violated.]

In order to acquire the logger instance you may use either

    src::severity_logger_mt< >& lg = get_my_logger();

or

    src::severity_logger_mt< >& lg = my_logger::get();

which are equivalent. Further usage of the logger is completely the same as it was a regular logger object of the corresponding type.

[endsect]

[endsect]


[section:sink_frontends Sink Frontends]

Every sink object that is compatible with the logging library is required to support interface `sink< CharT >`, where `CharT` is the appropriate character type. This interface is used by logging core to perform sink-specific filtering and pass log records to sinks. Technically speaking, one can derive his class from the `sink` template and have his new-found sink, but for sake of code reusing and sink implementation simplicity the library suggests separated concepts of sink frontend and sink backend. Sink frontends derive from the `sink` template and encapsulate the logic of filtering and thread synchronization. Most probably you won't have to write your own frontend once you need to create a new type of sink, because the library provides a number of frontends that cover most use cases. See [link advanced.advanced.sink_backends Sink Backends] section for more details on interface between frontends and backends.

[section:unlocked Unlocked sink frontend]

    #include <boost/log/sinks/sink.hpp>

The unlocked sink frontend is implemented with the `unlocked_sink` class template. This frontend provides the most basic service for the backend, which is filtering. The `unlocked_sink` performs no thread synchronization when accessing the backend, assuming that either the synchronization is not needed or the synchronization is implemented in the backend. However, filtering is still thread-safe (that is, one can safely change filter in the `unlocked_sink` frontend while other threads are writing logs through this sink). This is the only sink frontend available in a single thread environment. The example of use is as follows:

    // Some sink backend (for simplicity synchronization code omitted)
    class my_backend :
        public sinks::basic_sink_backend< char, sinks::backend_synchronization_tag >
    {
    public:
        // The method is called for every log record being put into the sink backend
        void consume(values_view_type const& attributes, string_type const& message)
        {
            std::cout << message << std::endl;
        }
    };

    // The function registers my_backend sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // The simplest way, the backend is default-constructed
        boost::shared_ptr< sink< char > > sink1(new sinks::unlocked_sink< my_backend >);
        core->add_sink(sink1);

        // One can construct backend separately and pass it to the frontend
        boost::shared_ptr< my_backend > backend(new my_backend);
        boost::shared_ptr< sink< char > > sink2(new sinks::unlocked_sink< my_backend >(backend));
        core->add_sink(sink2);

        // You can manage filtering through the sink interface
        sink1->set_filter(flt::attr< int >("Severity") >= warning);
        sink2->set_filter(flt::attr< std::string >("Channel") == "net");
    }

[endsect]

[section:sync Synchronous sink frontend]

    #include <boost/log/sinks/sink.hpp>

The synchronous sink frontend is implemented with the `synchronous_sink` class template. It is similar to the `unlocked_sink` but additionally provides thread synchronization with a mutex before passing log records to the backend. All sink backends that support formatting currently require thread synchronization in the frontend.

The synchronous sink also introduce an ability to acquire a pointer to the locked backend. As long as the pointer exists, the backend is guaranteed not to be accessed from other threads, unless the access is done through another frontend or a direct reference to the backend. This feature can be useful if there is a need to perform some updates on the sink backend while other threads may be writing logs. Beware, though, that while the backend is locked any other thread that tries to write a log record to the sink gets blocked until the backend is released.

The usage is similar to the `unlocked_sink`.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create a backend and initialize it with a stream
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));

        // Wrap it into the frontend and register in the core
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);

        // You can manage filtering through the sink interface
        sink->set_filter(flt::attr< int >("Severity") >= warning);

        // You can also manage backend in a thread-safe manner
        {
            sinks::synchronous_sink< sinks::text_ostream_backend >::locked_backend_ptr p = sink.locked_backend();
            p->add_stream(boost::make_shared< std::ofstream >("test.log"));
            p->set_formatter(fmt::ostrm << "Level: " << fmt::attr< int >("Severity") << "Message: " << fmt::message());
        } // the backend gets released here
    }


[endsect]

[section:async Asynchronous sink frontend]

    #include <boost/log/sinks/sink.hpp>

The frontend is implemented in the `asynchronous_sink` class template. Like synchronous one, asynchronous sink frontend provides a way of synchronizing access to the backend. All log records are passed to the backend in a dedicated thread, which makes it suitable for backends that may block for a considerable amount of time (network and other hardware device-related sinks, for example). The internal thread of the frontend is spawned on the frontend constructor and joined on its destructor (which implies that the frontend destruction may block). Aside from that, the frontend is similar to the `synchronous_sink` class template.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create a backend and initialize it with a stream
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));

        // Wrap it into the frontend and register in the core
        boost::shared_ptr< sinks::asynchronous_sink< sinks::text_ostream_backend > > sink(new sinks::asynchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);

        // You can manage filtering through the sink interface
        sink->set_filter(flt::attr< int >("Severity") >= warning);

        // You can also manage backend in a thread-safe manner
        {
            sinks::asynchronous_sink< sinks::text_ostream_backend >::locked_backend_ptr p = sink.locked_backend();
            p->add_stream(boost::make_shared< std::ofstream >("test.log"));
            p->set_formatter(fmt::ostrm << "Level: " << fmt::attr< int >("Severity") << "Message: " << fmt::message());
        } // the backend gets released here
    }

[important If asynchronous logging is used in multi-module application, one should decide carefully when to unload dynamically loaded modules that write logs. The library has many places where it may end up using resources that are physically reside in the dynamically loaded module. Examples of such resources are virtual tables, string literals and functions. If it appears that either of these resources are used by the library, whereas the module in which they reside gets unloaded, the application will most probably crash. Strictly speaking, this problem persists with any sink type (and is not limited to sinks in the first place), but asynchronous sinks introduce an additional problem. User cannot tell which resources are used by the asynchronous sink because it works in a dedicated thread and use buffered log records. There is no general solution for this issue. Users are advised to either avoid dynamic module unloading during the application work time, or to avoid asynchronous logging. As an additional way to cope with the problem, one may try to shutdown all asynchronous sinks before unloading any modules, and after unloading re-create them. However, avoiding dynamic unloading is the only way to solve the problem completely.]

[endsect]

[endsect]


[section:sink_backends Sink Backends]

[section:text_ostream Text stream backend]

    #include <boost/log/sinks/text_ostream_backend.hpp>

The text output stream sink backend is the most generic backend provided by the library out of box. The backend is implemented in the `basic_text_ostream_backend` class template (`text_ostream_backend` and `wtext_ostream_backend` convenience typedefs provided for narrow and wide character support). It supports formatting log records into strings and putting into one or several streams. Each attached stream gets the same result of formatting, so if you need to format log records differently for different streams, you will need to create several sinks - each with its own formatter.

The sink backend is compatible with any stream that derives from the `std::basic_ostream` class template. However, the sink can provide additional information about written data if the stream object also publicly derives from `record_writer` interface class. This interface declares methods that are called by the backend before and after each record is put into the stream. These hints can be used by the stream implementation to delimit log records (for example, an XML-writing stream could insert tags and indentation between log records) or perform other actions aligned to log records (for example, rotate the file without cutting a log record in the middle).

The backend provides another feature that may come useful when debugging your application. With `auto_flush` method one can enable the sink to automatically flush buffers of all attached streams after each log record written. This will, of course, degrade logging performance, but in case of application crash there is a good probability that last log records are not lost.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create a backend and attach a couple of streams to it
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));
        backend->add_stream(boost::shared_ptr< std::ostream >(new std::ofstream("test.log")));

        // Enable auto-flushing after each log record written
        backend->auto_flush(true);

        // Wrap it into the frontend and register in the core. The backend requires synchronization in the frontend.
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);
    }

[endsect]

[section:syslog Syslog backend]

    #include <boost/log/sinks/syslog_backend.hpp>

The syslog backend, as it comes from its name, provides support for syslog API that is available on virtually any UNIX or Linux platform. On Windows there is no  known implementation of the syslog API, therefore the backend is not available on this platform.

The backend is implemented in the `basic_syslog_backend` class template, `syslog_backend` and `wsyslog_backend` convenience typedefs are also available. The backend supports formatting log records, and therefore requires thread synchronization in the frontend. The backend also supports severity level translation from the application-specific values to the syslog-defined values. This is achieved with an additional function object, level extractor, that receives a set of attribute values of each log record and returns appropriate syslog level value. This value is used by the backend in the `LOG_MAKEPRI` macro to construct the final priority value of the syslog record. The other argument of the `LOG_MAKEPRI` macro, the facility, is constant for each backend object and can be specified in the backend constructor arguments.

Level extractors can be written by library users to map the application log levels to the syslog levels the best way. However, the library provides two extractors that would fit this need in obvious cases. The `direct_level_mapping` class template provides a way to directly map values of some integral attribute to syslog levels. The `custom_level_mapping` class template adds some flexibility and allows to map arbitrary values of some integral attribute to syslog levels. The `wdirect_level_mapping` and `wcustom_level_mapping` are also available for wide-character logging.

One additional thing should be noted. Syslog API allows to customize the service behavior by specifying additional flags to the `openlog` call. The backend too supports this feature - the options can be passed to the backend constructor. However, since `openlog` is only called once per logging session, the constructor argument is only taken into consideration for the first backend object being created.

Anyway, one example is better than a thousand words.

    // The function registers syslog sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create a backend. Specify facility and options in the constructor.
        boost::shared_ptr< sinks::syslog_backend > backend(new sinks::syslog_backend(
            sinks::syslog::user, sinks::syslog::console_fallback | sinks::syslog::log_pid));

        // Set the straightforward level translator for the "Severity" attribute of type int
        backend->set_level_extractor(sinks::syslog::direct_level_mapping< >("Severity"));

        // Wrap it into the frontend and register in the core. The backend requires synchronization in the frontend.
        boost::shared_ptr< sinks::synchronous_sink< sinks::syslog_backend > > sink(new sinks::synchronous_sink< sinks::syslog_backend >(backend));
        core->add_sink(sink);

        // Create a new backend. No use to specify options here.
        backend.reset(new sinks::syslog_backend(sinks::syslog::local0));

        // Create and fill in another level translator for "MyLevel" attribute of type string
        sinks::syslog::custom_level_mapping< std::string > mapping("MyLevel");
        mapping["debug"] = sinks::syslog::debug;
        mapping["normal"] = sinks::syslog::info;
        mapping["warning"] = sinks::syslog::warning;
        mapping["failure"] = sinks::syslog::critical;
        backend->set_level_extractor(mapping);

        // Wrap it into the frontend and register in the core.
        sink.reset(new sinks::synchronous_sink< sinks::syslog_backend >(backend));
        core->add_sink(sink);
    }

Please note that all syslog constants, as well as level extractors, are declared within a nested namespace `syslog`. The library will not accept (and does not declare in the backend interface) native syslog constants, which are macros, actually.

[endsect]

[section:debugger Windows debugger output backend]

    #include <boost/log/sinks/debug_output_backend.hpp>

The Windows OS provides an interesting feature: a process, being run under debugger, is able to emit messages that will be intercepted and displayed in the debugger window. For example, if an application is run under Visual Studio IDE it will be able to write debug messages to the IDE window. This backend provides a simple way of emitting such messages. Additionally, in order to optimize application performance, a special filter is available that checks whether the application is run under debugger. Like many other sink backends, this backend also supports setting a formatter in order to compose message text.

The usage is quite simple and straightforward:

    // The function registers debugger output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create the sink. The backend requires synchronization in the frontend.
        boost::shared_ptr< sinks::synchronous_sink< sinks::debug_output_backend > > sink(new sinks::synchronous_sink< sinks::debug_output_backend >());

        // Set the special filter to the frontend in order to skip the sink when no debugger is available
        sink->set_filter(sinks::debug_output_backend::debugger_presence_filter());

        core->add_sink(sink);
    }

[endsect]

[section:event_log Windows event log backends]

    #include <boost/log/sinks/event_log_backend.hpp>

The Windows OS provides a special API for publishing events related to the application execution. Wide range of applications, including Windows components, use this facility to provide user with all essential information about computer health in a single place - an event log. There can be more than one event logs, however, typically all user-space applications use the common Application log. Records from different applications or their parts can be selected from the log by a record source name. Event logs can be read with a standard utility, an Event Viewer, that comes with Windows installation.

Although it looks very tempting, the API is quite complicated and intrusive, which makes it difficult to support. The application is required to provide a dynamic library with special resources that describe all events the application supports. This library must be registered in the Windows registry, which pins its location on the file system. The Event Viewer uses this registration to find the resources and compose and display messages. The positive feature of this approach is that since event resources can describe events differently for different languages, it allows application to support event internationalization in a quite transparent manner: the application simply provides event identifiers and non-localizable event parameters to the API, and it does the rest of the work.

In order to support both the simplistic approach "it just works" and the more elaborate event composition, including internationalization support, the library provides two sink backends that work with event log API.

[heading Simple event log backend]

The `simple_event_log_backend` backend is intended to encapsulate as much of the event log API as possible, leaving interface and usage model very similar to other sink backends. It contains all needed resources that are needed for the Event Viewer to function properly, and registers the Boost.Log library in the Windows registry in order to populate itself as the container of these resources.

[note The library must be built as a dynamic library in order to use this backend flawlessly. Otherwise event description resources are not linked into the executable, and the Event Viewer is not able to display events properly.]

The only thing user has to do to add Windows event log support to his application is to provide event source and log names (which are optional and can be automatically suggested by the library), setup appropriate filter, formatter and event severity mapping. There is an `event_log` example available in the library directory that shows how to use the backend.

    // Define application-specific severity levels
    enum severity_levels
    {
        normal,
        warning,
        error
    };

    // The function registers the Windows event log backend
    void foo()
    {
        // Create an event log sink
        boost::shared_ptr< sinks::simple_event_log_backend > backend(
            new sinks::simple_event_log_backend((
                sinks::keywords::log_name = "My Application", // by default it would have been Application
                sinks::keywords::log_source = "My Source"     // by default it would have been based on the application executable name
            ))
        );
        boost::shared_ptr< sinks::synchronous_sink< sinks::simple_event_log_backend > > sink(
            new sinks::synchronous_sink< sinks::simple_event_log_backend >(backend));

        // Setup the message formatter
        backend->set_formatter(
            fmt::format("%1%: [%2%] - %3%")
                % fmt::attr< unsigned int >("Line #")
                % fmt::date_time< boost::posix_time::ptime >("TimeStamp")
                % fmt::message()
            );

        // We'll have to map our custom levels to the event log event types
        sinks::event_log::custom_event_type_mapping< severity_levels > mapping("Severity");
        mapping[normal] = sinks::event_log::info;
        mapping[warning] = sinks::event_log::warning;
        mapping[error] = sinks::event_log::error;

        backend->set_event_type_mapper(mapping);

        // Add the sink to the core
        logging::core::get()->add_sink(sink);
    }

Having done that, all logging records that pass to the sink will be formatted the same way they are in the other sinks. The formatted message will be displayed in the Event Viewer as the event description.

[heading Advanced event log backend]

The `event_log_backend` allows a more detailed control over the logging API, but requires considerably more scaffolding during initialization and usage.

First, user has to build his own library with the event resources (the process is described in [@http://msdn.microsoft.com/en-us/library/aa363681(VS.85).aspx MSDN]). As a part of this process one has to create a message file that describes all events. For sake of example, let's assume the following contents were used as the message file:

[pre
; /* --------------------------------------------------------
; HEADER SECTION
; */
SeverityNames=(Debug=0x0:MY_SEVERITY_DEBUG
            Info=0x1:MY_SEVERITY_INFO
            Warning=0x2:MY_SEVERITY_WARNING
            Error=0x3:MY_SEVERITY_ERROR
            )

; /* --------------------------------------------------------
; MESSAGE DEFINITION SECTION
; */

MessageIdTypedef=WORD

MessageId=0x1
SymbolicName=MY_CATEGORY_1
Language=English
Category 1
.

MessageId=0x2
SymbolicName=MY_CATEGORY_2
Language=English
Category 2
.

MessageId=0x3
SymbolicName=MY_CATEGORY_3
Language=English
Category 3
.

MessageIdTypedef=DWORD

MessageId=0x100
Severity=Warning
Facility=Application
SymbolicName=LOW_DISK_SPACE_MSG
Language=English
The drive %1 has low free disk space. At least %2 Mb of free space is recommended.
.

MessageId=0x101
Severity=Error
Facility=Application
SymbolicName=DEVICE_INACCESSIBLE_MSG
Language=English
The drive %1 is not accessible.
.

MessageId=0x102
Severity=Info
Facility=Application
SymbolicName=SUCCEEDED_MSG
Language=English
Operation finished successfully in %1 seconds.
.
]

After compiling the resource library, the path to this library must be provided to the sink backend constructor, among other parameters used with the simple backend. The path may contain placeholders that will be expanded with the appropriate environment variables.

    // Create an event log sink
    boost::shared_ptr< sinks::event_log_backend > backend(
        new sinks::event_log_backend((
            sinks::keywords::message_file = "%SystemDir%\\my_events.dll",
            sinks::keywords::log_name = "My Application",
            sinks::keywords::log_source = "My Source"
        ))
    );

Like the simple backend, the `event_log_backend` will register itself in the Windows registry, which will enable the Event Viewer to display the emitted events.

Next, user will have to provide mapping between the application logging attributes and event identifiers. These identifiers were provided in the message compiler output as a result of compiling the message file. One can use `event_composer` and one of the event ID mappings, like in the following example:

    // Create an event composer. It is initialized with the event identifier mapping.
    sinks::event_log::event_composer composer(sinks::event_log::direct_event_id_mapping< int >("EventID"));

    // For each event described in the message file, set up the insertion string formatters
    composer[LOW_DISK_SPACE_MSG]
        % fmt::attr< std::string >("Drive")      // the first placeholder in the message will be replaced with contents of the "Drive" attribute
        % fmt::attr< boost::uintmax_t >("Size"); // the second placeholder in the message will be replaced with contents of the "Size" attribute

    composer[DEVICE_INACCESSIBLE_MSG]
        % fmt::attr< std::string >("Drive");

    composer[SUCCEEDED_MSG]
        % fmt::attr< unsigned int >("Duration");

    // Then put the composer to the backend
    backend->set_event_composer(composer);

As you can see, one can use regular [link advanced.advanced.formatters formatters] to specify which attributes will be inserted instead of placeholders in the final event message. Aside from that, one can specify mappings of attribute values to event types and categories:

    // Define application-specific severity levels
    enum severity_levels
    {
        normal,
        warning,
        error
    };

    // We'll have to map our custom levels to the event log event types
    sinks::event_log::custom_event_type_mapping< severity_levels > type_mapping("Severity");
    type_mapping[normal] = sinks::event_log::make_event_type(MY_SEVERITY_INFO);
    type_mapping[warning] = sinks::event_log::make_event_type(MY_SEVERITY_WARNING);
    type_mapping[error] = sinks::event_log::make_event_type(MY_SEVERITY_ERROR);

    backend->set_event_type_mapper(type_mapping);

    // Same for event categories. Usually event categories can be restored by the event identifier.
    sinks::event_log::custom_event_category_mapping< int > cat_mapping("EventID");
    cat_mapping[LOW_DISK_SPACE_MSG] = sinks::event_log::make_event_category(MY_CATEGORY_1);
    cat_mapping[DEVICE_INACCESSIBLE_MSG] = sinks::event_log::make_event_category(MY_CATEGORY_2);
    cat_mapping[SUCCEEDED_MSG] = sinks::event_log::make_event_category(MY_CATEGORY_3);

    backend->set_event_category_mapper(cat_mapping);

[note In Windows NT 6 (Vista, Server 2008) and later it is not needed to specify event type mappings. This information is available in the message definition resources and need not to be duplicated in the API call.]

Now that initialization is done, the sink can be registered into the core.

    // Create the frontend for the sink
    boost::shared_ptr< sinks::synchronous_sink< sinks::event_log_backend > > sink(
        new sinks::synchronous_sink< sinks::event_log_backend >(backend));

    // Set up filter to pass only records that have the necessary attribute
    sink->set_filter(flt::has_attr< int >("EventID"));

    logging::core::get()->add_sink(sink);

In order to emit events it is convenient to create a set of functions that will accept all needed parameters for the corresponding events and announce that the event has occurred.

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(event_logger, src::severity_logger_mt< severity_levels >)

    // The function raises an event of the disk space depletion
    void announce_low_disk_space(std::string const& drive, boost::uintmax_t size)
    {
        BOOST_LOG_SCOPED_THREAD_TAG("EventID", int, LOW_DISK_SPACE_MSG);
        BOOST_LOG_SCOPED_THREAD_TAG("Drive", std::string, drive);
        BOOST_LOG_SCOPED_THREAD_TAG("Size", boost::uintmax_t, size);
        // Since this record may get accepted by other sinks, this message is not completely useless
        BOOST_LOG_SEV(event_logger::get(), warning) << "Low disk " << drive
            << " space, " << size << " Mb is recommended";
    }

    // The function raises an event of inaccessible disk drive
    void announce_device_inaccessible(std::string const& drive)
    {
        BOOST_LOG_SCOPED_THREAD_TAG("EventID", int, DEVICE_INACCESSIBLE_MSG);
        BOOST_LOG_SCOPED_THREAD_TAG("Drive", std::string, drive);
        BOOST_LOG_SEV(event_logger::get(), error) << "Cannot access drive " << drive;
    }

    // The structure is an activity guard that will emit an event upon the activity completion
    struct activity_guard
    {
        activity_guard()
        {
            // Add a stop watch attribute to measure the activity duration
            boost::shared_ptr< attrs::timer > attr(new attrs::timer());
            m_it = event_logger::get().add_attribute("Duration", attr);
        }
        ~activity_guard()
        {
            BOOST_LOG_SCOPED_THREAD_TAG("EventID", int, SUCCEEDED_MSG);
            BOOST_LOG_SEV(event_logger::get(), normal) << "Activity ended";
            event_logger::get().remove_attribute(m_it);
        }

    private:
        event_logger::logger_type::attribute_set_type::iterator m_it;
    };

[endsect]

[endsect]


[section:filters Filters]

As it was pointed out in [link tutorial.tutorial.filters tutorial], filters are implemented as Lambda-like expressions with placeholders for attribute values. This section will describe placeholders that can be used to build more complex expressions.

[section:has_attr Attribute presence filter]

    #include <boost/log/filters/has_attr.hpp>

The filter `has_attr` checks if an attribute value with specified name and, optionally, type is attached to a log record. If no type specified to the filter, the filter returns `true` if any-typed value with the specified name is found. If an MPL-compatible type sequence in specified as a value type, the filter returns `true` if a value with the specified name and one of the specified types is found.

This filter is usually used in conjunction with [link advanced.advanced.formatters.conditional conditional formatters], but it also can be used as a quick filter based on the log record structure. For example, one can use this filter to extract statistic records and route them to a specific sink.

    // A simple sink backend to accumulate statistic information
    class my_stat_accumulator :
        public sinks::basic_sink_backend< char, sinks::backend_synchronization_tag >
    {
        // A map of accumulated statistic values, ordered by the statistic information stream name
        std::map< std::string, int > m_StatInfo;

    public:
        // Destructor
        ~my_stat_accumulator()
        {
            // Display the accumulated data
            for (std::map< std::string, int >::const_iterator it = m_StatInfo.begin(); it != m_StatInfo.end(); ++it)
            {
                std::cout << "Statistic stream: " << it->first << ", accumulated value: " << it->second << "\n";
            }
            std::cout.flush();
        }

        // The method is called for every log record being put into the sink backend
        void consume(values_view_type const& attributes, string_type const& message)
        {
            // First, acquire statistic information stream name
            values_view_type::const_iterator itName = attributes.find("StatisticStream");
            if (itName != attributes.end())
            {
                boost::optional< std::string const& > name = itName->second.get< std::string >();
                if (name)
                {
                    // Next, get the statistic value change
                    values_view_type::const_iterator itChange = attributes.find("Change");
                    if (itChange != attributes.end())
                    {
                        boost::optional< int const& > change = itChange->second.get< int >();
                        if (change)
                        {
                            // Accumulate the statistic data
                            m_StatInfo[name.get()] += change.get();
                        }
                    }
                }
            }
        }
    };

    // The function registers two sinks - one for statistic information, and another one for other records
    void foo()
    {
        boost::shared_ptr< logging::core > core = logging::core::get();

        // Create a backend and attach a stream to it
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(new std::ofstream("test.log")));

        // Create a frontend and setup filtering
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        // All records that don't have a "StatisticStream" attribute attached will go to the "test.log" file
        sink->set_filter(!flt::has_attr("StatisticStream"));

        core->add_sink(sink);

        // Create another sink that will receive all statistic data
        boost::shared_ptr< sinks::synchronous_sink< my_stat_accumulator > > stat_sink(new sinks::synchronous_sink< my_stat_accumulator >);
        // All records with a "StatisticStream" string attribute attached will go to the my_stat_accumulator sink
        sink->set_filter(flt::has_attr< std::string >("StatisticStream"));

        core->add_sink(stat_sink);
    }

    // This simple macro will simplify putting statistic data into a logger
    #define PUT_STAT(lg, stat_stream, change)\
        if (true) {\
            BOOST_LOG_SCOPED_LOGGER_TAG(lg, "StatisticStream", std::string, stat_stream);\
            BOOST_LOG_SCOPED_LOGGER_TAG(lg, "Change", int, change);\
            BOOST_LOG(lg);\
        } else ((void)0)

    void bar()
    {
        src::logger lg;

        // Put a regular log record, it will go to the "test.log" file
        BOOST_LOG(lg) << "A regular log record";

        // Put some statistic data
        PUT_STAT(lg, "StreamOne", 10);
        PUT_STAT(lg, "StreamTwo", 20);
        PUT_STAT(lg, "StreamOne", -5);
    }

Please note that in the example above we extended the library in two ways: we defined a new sink backend `my_stat_accumulator` and a new macro `PUT_STAT`. Also note the technique of extracting attribute value from the view - we need to both check that the needed attribute value is found in the view and that it has the needed type. There is also a mechanism of [link advanced.advanced.utilities.extractors attribute value extractors] that can simplify this, especially when an attribute can have a number of types.

[endsect]

[section:attr Generic attribute placeholder]

    #include <boost/log/filters/attr.hpp>

Unlike `has_attr`, `attr` construct is not a complete filter by itself. Instead, it is a placeholder that may take part in a complete filter expressions like this:

    sink->set_filter(flt::attr< int >("Severity") >= 5 && flt::attr< std::string >("Channel") == "net");

The line above registers a composite filter that consists of two elementary subfilters: the first one checks the severity level, and the second checks the channel name. Like `has_attr`, the `attr` placeholder accepts an expected attribute value type or set of types in an MPL-compatible type sequence. However, attribute value type is not optional with `attr`, like it is with `has_attr`.

Besides generating lambda expressions, the `attr` placeholder allows to construct filters with its member functions. There are currently two such members that can be used with any type:

* `is_in_range(T const& lower, T const& upper)` generates a filter that returns `true` if the attribute value `x` of type `T` satisfies condition `lower <= x < upper`. For example:

    sink->set_filter(flt::attr< int >("Severity").is_in_range(3, 5)); // drops all records that have level below 3 or greater than 4

* `satisfies(FunT const& fun)` allows to inject a user-defined unary predicate `fun` into the filter. The predicate should accept an attribute value as an argument and return a value, convertible to boolean. The result of the filter will be equivalent to the result of the predicate. For example:

    bool check_severity_level(int level);

    sink->set_filter(flt::attr< int >("Severity").satisfies(&check_severity_level));

The `attr` placeholder has an advanced support for string-typed attribute values (that have type `std::string` or `std::wstring`, that is). For string attribute values there are also available the following member functions:

* `begins_with(T const& s)`, `ends_with(T const& s)` and `contains(T const& s)`. As follows from their names, the functions construct filters that return `true` if an attribute value begins with, ends with or contains the specified substring `s`, respectively. The string comparison is case sensitive.

    sink->set_filter(flt::attr< std::string >("Domain").ends_with(".ru")); // selects only records that are related to Russian web domains

* `matches(T const& regex)` allows to set up a filter based on __boost_regex__ regular expressions matching mechanism. The filter returns `true` if the attribute value matches the `regex` expression.

    sink->set_filter(flt::attr< std::string >("Domain").matches("www\\..*\\.ru"));

[endsect]

[endsect]

[section:formatters Formatters]

As it was noted in the [link tutorial.tutorial.formatters tutorial], the library provides two ways of expressing formatters: with a stream-style syntax or __boost_format__-style expression. Which of the two formats is chosen is determined with the appropriate anchor expression. To use stream-style syntax one should begin formatter definition with a `ostrm` or `wostrm` keyword, like that:

    #include <boost/log/formatters/ostream.hpp>

    backend->set_formatter(fmt::ostrm << expr1 << expr2 << ... << exprN);

Here expressions `expr1` through `exprN` may be either manipulators, described in this section, or other expressions resulting in an object that supports putting into an STL-stream. Note that `boost::ref` is also supported, which allows to inject references into the formatter object.

To use __boost_format__-style syntax one should use `format` construct:

    #include <boost/log/formatters/format.hpp>

    backend->set_formatter(fmt::format("format string") % expr1 % expr2 % ... % exprN);

The format string passed to the `format` keyword should contain positional placeholders for the appropriate expressions. In case of wide-character logging the format string should be wide. Expressions `expr1` through `exprN` have the same meaning as in stream-like variant. It should be noted, though, that using stream-like syntax usually results in a faster formatter than the one is constructed with the `format` keyword.

[section:attr Generic attribute formatter]

    #include <boost/log/formatters/attr.hpp>

The `attr` formatter is the most generic and simple way to format an attribute value. In the simplest form it is equivalent to putting the specified attribute value into an STL stream with an `operator <<` associated with the attribute value type. For example:

    // A custom attribute value type
    struct A
    {
        int n;
        std::string s;
    };

    // This operator will be called by the formatter
    std::ostream& operator<< (std::ostream& strm, A const& val)
    {
        strm << "[n = " << val.n << ", s = " << val.s << "]";
        return strm;
    }

    // Sets the formatter to a sink backend
    backend->set_formatter(fmt::ostrm << fmt::attr< A >("MyAttribute"));

This will also work with __boost_format__-style syntax since it falls back to streams internally:

    // Sets the formatter to a sink backend
    backend->set_formatter(fmt::format("%1%") % fmt::attr< A >("MyAttribute"));

Like filters, formatters also support specifying a set of possible types of the attribute values in MPL-compatible sequences. For example, you can format an attribute that may have some integral type like this:

    typedef boost::mpl::vector< short, int, long >::type types;
    backend->set_formatter(fmt::ostrm << fmt::attr< types >("MyInteger"));

The `attr` formatter also supports an additional argument with a __boost_format__ format string. This feature can be used to specify formatting rules for numbers and/or decorate the formatted attribute somehow. For example:

    typedef boost::mpl::vector< short, int, long >::type types;
    backend->set_formatter(fmt::ostrm << fmt::attr< types >("MyInteger", "[%08x]")); // will print the "MyInteger" attribute value as 8-digit hex in square brackets

Please note, though, that the format string should be valid for all attribute value types that are specified as the template argument for the `attr` formatter. If this is not possible, one should consider using [link advanced.advanced.formatters.conditional conditional formatters] to split types into several groups and specify a valid format string for each group.

[endsect]

[section:date_time Date and time formatter]

    #include <boost/log/formatters/date_time.hpp>

The library provides several formatters dedicated to date and time-related attribute value types. These are `date`, `time`, `date_time`, `time_duration` and `time_period`. The `date` and `time` formatters are mostly included by `date_time`.

As it comes from its name, `date_time` is responsible for formatting time points. The supported attribute value types are: `std::tm`, `std::time_t` and `boost::posix_time::ptime` and `boost::local_time::local_date_time` from __boost_date_time__. Additionally, the `date` formatter also supports `boost::gregorian::date` type. Like with other formatters and filters, you can also explicitly specify the attribute type or set of types that you want to format.

The date and time format can be customized by user. The format should be passed as a named argument `format` to the appropriate formatter. This argument should be a format string, containing placeholders described in __boost_date_time__ documentation. Some usage examples as follows:

    // Puts a date of any of the supported types into log. The default format is "%Y-%b-%d".
    backend->set_formatter(fmt::ostrm << fmt::date("Date"));

    // Puts a time point of any of the supported types into log. The default format is "%H:%M:%S.%f".
    backend->set_formatter(fmt::ostrm << fmt::time("Time"));

    // Puts a date and time of the specified type into log. The default format is "%Y-%b-%d %H:%M:%S.%f".
    backend->set_formatter(fmt::ostrm << fmt::date_time< std::tm >("DateTime"));

    // Puts a date and time of one of the specified types into log.
    typedef boost::mpl::vector< std::time_t, std::tm, boost::posix_time::ptime >::type types;
    backend->set_formatter(fmt::ostrm << fmt::date_time< types >("DateTime", fmt::keywords::format = "%d.%m.%y %H:%M:%S"));

The `time_duration` formatter is responsible for formatting time periods that are not bound to a specific time point. It supports types `double` (interpreted as a result of the `difftime` standard function), `boost::posix_time::time_duration` and `boost::gregorian::date_duration`. The formatter also supports the `format` argument. The usage is straightforward:

    // Puts a time duration of any of the supported types into log. The default format is "%-%H:%M:%S.%f".
    backend->set_formatter(fmt::ostrm << fmt::time_duration("Duration"));

    // Puts a time duration of the specified type into log.
    backend->set_formatter(fmt::ostrm << fmt::time_duration< boost::posix_time::time_duration >("Duration", fmt::keywords::format = "%H:%M:%S"));

The `time_period` formatter composes two time points that denote a time period. It supports the following types: `boost::posix_time::time_period`, `boost::local_time::local_time_period` and `boost::gregorian::date_period`. The formatter is a bit more special since it supports two kinds of format strings, the one that describes the date format, and the one that describes the dates composition. The former can be specified with the named argument `unit_format` and the latter - with named argument `format`. The time period composition format string may contain either of the three placeholders:

* `%begin%` - the placeholder will be substituted with the starting time point of the period.
* `%last%` - the placeholder will be substituted with the last time point of the period.
* `%end%` - the placeholder will be substituted with the time point that is immediately after the time period.

Here are some usage examples:

    // Puts a time period of any of the supported types into log. The default composition format is [%begin% - %last%].
    backend->set_formatter(fmt::ostrm << fmt::time_period("Period"));

    // Puts a time period of the specified type into log.
    backend->set_formatter(fmt::ostrm << fmt::time_period< boost::posix_time::time_period >("Period",
        fmt::keywords::format = "[%begin%; %end%)", fmt::keywords::unit_format = "%d.%m.%y %H:%M:%S"));

[endsect]

[section:named_scope Named scope formatter]

    #include <boost/log/formatters/named_scope.hpp>

The formatter `named_scope` is intended to add support for flexible formatting of the [link advanced.advanced.attributes.named_scope named scope] attribute. The basic usage is quite straightforward and its result is similar to what [link advanced.advanced.formatters.attr `attr`] provides:

    // Puts the scope stack from outer ones towards inner ones: outer scope -> inner scope
    backend->set_formatter(fmt::ostrm << fmt::named_scope("Scopes"));

The formatter supports customization with the following named arguments:

* `scope_iteration`. The argument describes the direction of iteration through scopes. Can have values `forward` (default) or `reverse`.
* `scope_delimiter`. The argument can be used to specify the delimiters between scopes. The default delimiter depends on the `scope_iteration` argument. If `scope_iteration == forward` the default `scope_delimiter` will be "->", otherwise it will be "<-".
* `scope_depth`. The argument can be used to limit the number of scopes to put to log. The formatter will print `scope_depth` innermost scopes and, if there are more scopes left, append an ellipsis to the written sequence. By default the formatter will write all scope names.

Here are few usage examples:

    // Puts the scope stack in reverse order: inner scope <- outer scope
    backend->set_formatter(fmt::ostrm << fmt::named_scope("Scopes", fmt::keywords::scope_iteration = fmt::keywords::reverse));

    // Puts the scope stack in reverse order with a custom delimiter: inner scope | outer scope
    backend->set_formatter(fmt::ostrm << fmt::named_scope("Scopes",
        fmt::keywords::scope_iteration = fmt::keywords::reverse, fmt::keywords::scope_delimiter = " | "));

    // Puts the scope stack in forward order, no more than 2 inner scopes: ... -> outer scope -> inner scope
    backend->set_formatter(fmt::ostrm << fmt::named_scope("Scopes",
        fmt::keywords::scope_iteration = fmt::keywords::forward, fmt::keywords::scope_depth = 2));

    // Puts the scope stack in reverse order, no more than 2 inner scopes: inner scope <- outer scope <- ...
    backend->set_formatter(fmt::ostrm << fmt::named_scope("Scopes",
        fmt::keywords::scope_iteration = fmt::keywords::reverse, fmt::keywords::scope_depth = 2));

[endsect]

[section:conditional Conditional formatters]

    #include <boost/log/formatters/if.hpp>

There are cases when one would want to check some condition about the log record and format it depending on that condition. One example of such need is formatting an attribute value depending on its runtime type. The general syntax of the conditional formatter is as follows:

    if_ (filter)
    [
        true_formatter
    ]
    .else_
    [
        false_formatter
    ]

Ones that are familiar with __boost_phoenix__ lambda expressions will find this syntax quite familiar. The `filter` argument is a filter that is applied to the record being formatted. If it returns `true`, the `true_formatter` is executed, otherwise `false_formatter` is executed. The `else_` section with `false_formatter` is optional. If it is omitted and `filter` yields `false`, no formatter is executed. Here is an example:

    backend->set_formatter
    (
        fmt::ostrm
            << fmt::date_time("TimeStamp") << " "                      // First, put the current time
            << fmt::if_ (flt::has_attr< int >("ID"))
               [
                   fmt::ostrm << fmt::attr< int >("ID", "[0x%08x]")    // if "ID" is integral then format it as a hex number
               ]
               .else_
               [
                   fmt::ostrm << "[" << fmt::attr("ID") << "]"         // otherwise put it as it is
               ]
            << " " << fmt::message()                                   // and after that goes the log record text
    );

[endsect]

[section:message Message placeholder]

    #include <boost/log/formatters/message.hpp>

With all these attributes we shouldn't forget the log message itself, should we? There is a `message` placeholder that represents text of logging records being formatted. The usage is quite simple:

    // Sets up a formatter that will ignore all attributes and only print log record text
    backend->set_formatter(fmt::ostrm << fmt::message());

Please note, that for wide character logging there is a similar `wmessage` placeholder.

[endsect]

[endsect]

[section:attributes Attributes]

Every attribute supported by the library must derive from the `attribute` interface. This interface has the only virtual method named `get_value`. This method should return the actual attribute value object, derived from the `attribute_value` interface. Such separation allows to implement attributes that can return different values at different time points (like clock-related attributes, for example) and, on the other hand, allows to use different values of the same attribute independently.

The attribute value object is mostly intended to store the actual attribute value and implement type dispatching in order to be able to extract the stored value. One should not confuse the attribute value object type and the stored value type. The former is in most cases not needed by users and is hidden behind the `attribute_value` interface, but the latter is needed to be able to extract the value. For brevity we call the stored attribute value type simply as attribute value type in this documentation.

[section:constant Constants]

    #include <boost/log/attributes/constant.hpp>

The most simple and frequently used attribute type is a constant value of some type. This kind of attribute is implemented with the `constant` class template. The template is parametrized with the attribute value type. The constant value should be passed to the attribute constructor. Here is an example:

    void foo()
    {
        src::logger lg;

        // Register a constant attribute that always yields value -5
        boost::shared_ptr< attrs::attribute > attr(new attrs::constant< int >(-5));
        lg.add_attribute("MyInteger", attr);

        // Register another constant attribute. Make it a string this time.
        attr.reset(new attrs::constant< std::string >("Hello world!"));
        lg.add_attribute("MyString", attr);
    }

That's it, there's nothing much you can do with a constant attribute. Constants are very useful when one wants to highlight some log records or just pass some data to a sink backend (e.g. pass statistical parameters to the collector).

[endsect]

[section:mutable_constant Mutable constants]

    #include <boost/log/attribute/mutable_constant.hpp>

This kind of attribute is an extension for the [link advanced.advanced.attributes.constant constant attribute]. In addition to being able to store some value, the `mutable_constant` class template has two distinctions:

* it allows to modify the stored value without re-registering the attribute
* it allows to synchronize the stores and readings of the stored value

In order to change the stored value of the attribute, one must call the `set_value` method:

    void foo()
    {
        src::logger lg;

        // Register a mutable constant attribute that always yields value -5
        boost::shared_ptr< attrs::mutable_constant< int > > attr(new attrs::mutable_constant< int >(-5));
        lg.add_attribute("MyInteger", attr);
        BOOST_LOG(lg) << "This record has MyInteger == -5";

        // Change the attribute value
        attr->set_value(100);
        BOOST_LOG(lg) << "This record has MyInteger == 100";
    }

In multithreaded applications the `set_value` method calls must be serialized with the `get_value` calls (which, generally speaking, happen on every log record being made). By default `mutable_constant` does not serialize calls in any way, assuming that user will do so externally. However, `mutable_constant` template provides three additional template arguments: synchronization primitive type, scoped exclusive lock type and scoped shareable lock type. If synchronization primitive type is specified, the scoped exclusive lock type is a mandatory parameter. In this case, scoped shareable lock type is not specified, the attribute will fall back to the exclusive lock instead of shared locks. For example:

    // This mutable constant will always lock exclusively either for reading or storing the value
    typedef attrs::mutable_constant<
        int,                                        // attribute value type
        boost::mutex,                               // synchronization primitive
        boost::lock_guard< boost::mutex >           // exclusive lock type
    > exclusive_mc;
    boost::shared_ptr< exclusive_mc > my_int1;

    // This mutable constant will use shared clocking for reading the value and exclusive locking for storing
    typedef attrs::mutable_constant<
        int,                                        // attribute value type
        boost::shared_mutex,                        // synchronization primitive
        boost::unique_lock< boost::shared_mutex >,  // exclusive lock type
        boost::shared_lock< boost::shared_mutex >   // shared lock type
    > shared_mc;
    boost::shared_ptr< shared_mc > my_int2;

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::logger_mt)
    {
        src::logger_mt lg;

        my_int1.reset(new exclusive_mc(10));
        lg.add_attribute("MyInteger1", my_int1);

        my_int2.reset(new shared_mc(20));
        lg.add_attribute("MyInteger2", my_int2);

        return lg;
    }

    void foo()
    {
        src::logger_mt& lg = get_my_logger();

        // This is safe, even if executed in multiple threads
        my_int1->set_value(200);
        BOOST_LOG(lg) << "This record has MyInteger1 == 200";

        my_int2->set_value(300);
        BOOST_LOG(lg) << "This record has MyInteger2 == 300";
    }

Mutable constants are often used as auxiliary attributes inside loggers to store attributes that may change on some events. As opposed to regular constants, which would require re-registering in case of value modification, mutable constants allow to modify the value in-place.

[endsect]

[section:counter Counters]

    #include <boost/log/attributes/counter.hpp>

Counters are one of the simplest attributes that generate a new value each time requested. Counters are often used to identify log records or to count some events, e.g. accepted network connections. The class template `counter` provides such functionality. This template is parametrized with the counter value type, which should support arithmetic operations, such as `operator +` and `operator -`. The counter attribute allows to specify initial value and step (which can be negative) on construction.

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::logger_mt)
    {
        src::logger_mt lg;

        // This counter will count lines, starting from 0
        lg.add_attribute("LineCounter", boost::make_shared< attrs::counter< unsigned int >());

        // This counter will count backwards, starting from 100 with step -5
        lg.add_attribute("CountDown", boost::make_shared< attrs::counter< int >(100, -5));

        return lg;
    }

    void foo()
    {
        src::logger_mt& lg = get_my_logger();
        BOOST_LOG(lg) << "This record has LineCounter == 0, CountDown == 100";
        BOOST_LOG(lg) << "This record has LineCounter == 1, CountDown == 95";
        BOOST_LOG(lg) << "This record has LineCounter == 2, CountDown == 90";
    }

[note Don't expect that the log records with the `counter` attribute will always have ascending or descending counter values in the resulting log. In multithreaded applications counter values acquired in different threads may come to a sink in either order. See [link log.rationale.why_weak_record_ordering Rationale] for a more detailed explanation on why that can happen. For this reason it is more accurate to say that the `counter` attribute generates an identifier in an ascending or descending order rather than counts log records in either order.]

[endsect]

[section:clock Wall clock]

    #include <boost/log/attributes/clock.hpp>

One of the "must-have" features of any logging library is the support for attaching a time stamp to every log record. The library provides two attributes for this purpose: `utc_clock` and `local_clock`. The former returns current UTC time and the latter returns current local time. In either case the returned time stamp is acquired with maximum precision for the target platform. The attribute value is `boost::posix_time::ptime` (see __boost_date_time__). The usage is quite straightforward:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

    void foo()
    {
        logging::core::get()->register_global_attribute("TimeStamp", boost::make_shared< attrs::local_clock >());

        // Now every log record ever made will have a time stamp attached
        src::logger_mt& lg = get_my_logger();
        BOOST_LOG(lg) << "This record has a time stamp";
    }

[endsect]

[section:timer Stop watch]

    #include <boost/log/attributes/timer.hpp>

The `timer` attribute is very useful when there is a need to estimate duration of some prolonged process. The attribute returns time duration elapsed since the attribute construction. The attribute value type is `boost::posix_time::ptime::time_duration_type` (see __boost_date_time__).

    // The class represents a single peer-to-peer connection
    class network_connection
    {
        src::logger m_Logger;

    public:
        network_connection()
        {
            m_Logger.add_attribute("Duration", boost::make_shared< attrs::timer >());
            BOOST_LOG(m_Logger) << "Connection established";
        }
        ~network_connection()
        {
            // This log record will show the whole life time duration of the connection
            BOOST_LOG(m_Logger) << "Connection closed";
        }
    };

The attribute provides high resolution of the time estimation and even can be used as a simple in-place performance profiling tool.

[tip The `timer` attribute can even be used to profile the code in different modules without recompiling them. The trick is to wrap an expensive call a foreign module with the thread-specific `timer` [link advanced.advanced.utilities.scoped_attributes scoped attribute], which will markup all log records made from within the module with time readings.]

[endsect]

[section:named_scope Named scopes]

    #include <boost/log/attributes/named_scope.hpp>

The logging library supports maintaining scopes stack tracking during the application execution. This stack may either be written to log or be used for other needs (for example, to save the exact call sequence that led to and exception when throwing one). Each stack element contains following information (see `basic_named_scope_entry` structure template definition):

* Scope name. It can be defined by user or generated by compiler, but in any case it [_must be a constant string literal] (see [link log.rationale.why_str_lit Rationale]).
* Source file name, where the scope begins. It is usually a result of the standard `__FILE__` macro expansion. Like scope name, the file name [_must be a constant string literal].
* Line number in the source file. Usually it is a result of the standard `__LINE__` macro expansion.

The scope stack is implemented through a thread-specific global storage internally. There is a `named_scope` (`wnamed_scope` for wide-character logging) attribute that allows to hook this stack into logging pipeline. This attribute generates value of the nested type `named_scope::scope_stack` which is the instance of the scope stack. The attribute can be registered the following way:

    logging::core::get()->add_global_attribute("Scope", boost::make_shared< attrs::named_scope >());

Note it is perfectly valid to register the attribute globally because the scope stack is thread-local anyway. This will also implicitly add scope tracking to all threads of the application, which is often exactly what we need.

Now we can mark execution scopes with macros `BOOST_LOG_FUNCTION` and `BOOST_LOG_NAMED_SCOPE` (the latter accepts the scope name as an argument). These macros automatically add source position information to each scope entry. An example follows:

    void foo(int n)
    {
        // Mark the scope of the function foo
        BOOST_LOG_FUNCTION();

        switch (n)
        {
        case 0:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 0");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        case 1:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 1");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        default:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("default");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;
        }
    }

After executing `foo` we will be able to see in log that the `bar` function was called from `foo` and, more precisely, from the case statement that corresponds the value of `n`. This may be very useful when tracking down subtle bugs that show only when `bar` is called from a specific location (e.g. if `bar` is being passed invalid arguments in that particular location).

Another good use case is attaching the scope stack information to an exception. With help of __boost_exception__, this is possible:

    typedef boost::error_info< struct tag_scopes, attrs::named_scope::scope_stack > scopes_info;

    void bar(int x)
    {
        BOOST_LOG_FUNCTION();

        if (x < 0)
        {
            // Attach a copy of the current scope stack to the exception
            throw boost::enable_error_info(std::range_error("x must not be negative"))
                << scopes_info(attrs::named_scope::get_scopes());
        }
    }

    void foo()
    {
        BOOST_LOG_FUNCTION();

        try
        {
            bar(-1);
        }
        catch (std::range_error& e)
        {
            // Acquire the scope stack from the exception object
            BOOST_LOG(lg) << "bar call failed: " << e.what() << ", scopes stack:\n"
                << *boost::get_error_info< scopes_info >(e);
        }
    }

Note that we do not inject the `named_scope` attribute into the exception. Since scope stacks are maintained globally, throwing an exception will cause stack unwinding and, as a result, will truncate the global stack. Instead we create a copy of the scope stack at the throw site. This copy will be kept intact even if the global stack instance changes during stack unwinding.

[endsect]

[section:functor Function objects as attributes]

    #include <boost/log/attributes/functor.hpp>

This attribute is a simple wrapper around a user-defined function object. Each attempt to acquire the attribute value results in the function object call. The result of the call is returned as the attribute value (this implies that the function must not return `void`). The functor attribute can be constructed with the `make_functor_attr` helper function, like this:

    void foo()
    {
        logging::core::get()->register_global_attribute("MyRandomAttr", attrs::make_functor_attr(&std::rand));
    }

Auto-generated function objects, like the ones defined in __boost_bind__, __boost_lambda__, or STL, are also supported.

[note Some deficient compilers may not support `result_of` construct properly. This metafunction is used in the `make_functor_attr` function to automatically detect the return type of the function object. In case if `result_of` breaks, one may try to explicitly specify the return type of the function object as a template argument to the `make_functor_attr` function.]

[endsect]

[endsect]

[section:utilities Utilities]

[section:string_literal String literals]

    #include <boost/log/utility/string_literal.hpp>

String literals are used in several places throughout the library. However, this component can be successfully used outside of the library in users code. It is header-only and does not require linking with the library binary. String literals can improve performance significantly if there is no need to modify stored strings. What is also important, since string literals do not dynamically allocate memory, it is easier to maintain exception safety when using string literals instead of regular strings.

The functionality is implemented in `basic_string_literal` class template, which is parametrized with character and character traits, similar to `std::basic_string`. There are also two convenience typedefs provided: `string_literal` and `wstring_literal`, for narrow and wide character types, respectively. In order to ease string literal construction in generic code there is also a `str_literal` function template that accepts a string literal and returns a `basic_string_literal` instance for the appropriate character type.

String literals support interface similar to STL strings, except for string modification functions. However, it is possible to assign to or clear string literals, as long as only string literals involved. Relational and stream output operators are also supported. A more detailed information is given in the [classref boost::log::basic_string_literal Reference section].

[endsect]

[section:type_info_wrapper Type information wrapper]

    #include <boost/log/utility/type_info_wrapper.hpp>

The language support for run time type information is essential for the library. But partially because of limitations that C++ Standard poses on this feature, partially because of differences of implementation of different compilers, there was a need for a lightweight wrapper around `std::type_info` class to fill the gaps. The table below briefly shows the differences between the `std::type_info` and `type_info_wrapper` classes.

[table Type information classes comparison
    [[Feature]                                  [`std::type_info`]              [`type_info_wrapper`]]
    [[Is default-constructable]                 [No]                            [Yes. The default-constructed wrapper is in an empty state.]]
    [[Is copy-constructable]                    [No]                            [Yes]]
    [[Is assignable]                            [No]                            [Yes]]
    [[Is swappable]                             [No]                            [Yes]]
    [[Is singleton]                             [Yes, as defined in C++ Standard. Not every compiler conforms to this requirement, though.] [No]]
    [[Life time duration]                       [Static, until the application terminates] [Dynamic]]
    [[Has an empty state]                       [No]                            [Yes. In empty state the type info wrapper is never equal to other non-empty type info wrappers. It is equal to other empty type info wrappers and can be ordered with them.]]
    [[Supports equality comparison]             [Yes]                           [Yes]]
    [[Supports ordering]                        [Yes, partial ordering with the `before` method.] [Yes, partial ordering with the complete set of comparison operators. The semantics of ordering is similar to the `std::type_info::before` method.]]
    [[Supports printable representation of type] [Yes, with `name` and `raw_name` functions.] [Yes, with `pretty_name` function. The function makes its best to print the type name in a human-readable form.]]
]

Given the distinctions above, using type information objects becomes much easier. For example, ability to copy and order with regular operators allows to use `type_info_wrapper` with containers. Ability to default-construct and assign allows to use type information as a regular objects an not to resort to pointers which may be unsafe.

[endsect]

[section:scoped_attributes Scoped attributes]

    #include <boost/log/utility/scoped_attribute.hpp>

Scoped attributes are a powerful mechanism of tagging log records that can be used for different purposes. As the naming implies, scoped attributes are registered in the beginning of a scope and unregistered on the end of the scope. The mechanism includes the following four macros:

    BOOST_LOG_SCOPED_LOGGER_ATTR(logger, attr_name, attr_type);
    BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR(logger, attr_name, attr_type, attr_ctor_args);

    BOOST_LOG_SCOPED_THREAD_ATTR(attr_name, attr_type);
    BOOST_LOG_SCOPED_THREAD_ATTR_CTOR(attr_name, attr_type, attr_ctor_args);

The former two register a source-specific attribute in the `logger` logger object. The attribute name and type are given in the `attr_name` and `attr_type` arguments. The BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR additionally accepts a __boost_preprocessor__ sequence of arguments that should be passed to the attribute constructor. The latter pair of macros do exactly the same but the attribute is registered for the current thread in the logging core (which does not require a logger).

[note If it appears that a same-named attribute is already registered in the logger/logging core, the macros won't override the existing attribute and will eventually have no effect. See [link log.rationale.why_weak_scoped_attributes Rationale] for a more detailed explanation of reasons for such behavior.]

Usage example follows:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

    void foo()
    {
        // This log record will too be marked with the "Tag" attribute, whenever it is called from the A::bar function.
        // It will not be marked when called from other places.
        BOOST_LOG(get_my_logger()) << "A log message from foo";
    }

    struct A
    {
        src::logger m_Logger;

        void bar()
        {
            // Set a thread-wide markup tag. Note the additional parenthesis to form a Boost.PP sequence.
            BOOST_LOG_SCOPED_THREAD_ATTR_CTOR("Tag", attrs::constant< std::string >, ("Called from A::bar"));

            // This log record will be marked
            BOOST_LOG(m_Logger) << "A log message from A::bar";

            foo();
        }
    };

    int main(int, char*[])
    {
        src::logger lg;

        // Let's measure our application run time
        BOOST_LOG_SCOPED_LOGGER_ATTR(lg, "RunTime", attrs::timer);

        // Mark application start. The "RunTime" attribute should be nearly 0 at this point.
        BOOST_LOG(lg) << "Application started";

        // Note that no other log records are affected by the "RunTime" attribute.
        foo();

        A a;
        a.bar();

        // Mark application ending. The "RunTime" attribute will show the execution time elapsed.
        BOOST_LOG(lg) << "Application ended";

        return 0;
    }

It is quite often convenient to mark a group of log records with a constant value in order to be able to filter the records later. The library provides two convenience macros just for this purpose:

    BOOST_LOG_SCOPED_LOGGER_TAG(logger, tag_name, tag_type, tag_value);
    BOOST_LOG_SCOPED_THREAD_TAG(tag_name, tag_type, tag_value);

The macros are effectively wrappers around `BOOST_LOG_SCOPED_LOGGER_ATTR_CTOR` and `BOOST_LOG_SCOPED_THREAD_ATTR_CTOR`, respectively. For example, the "Tag" scoped attribute from the example above can be registered like this:

    // Note there is no "attrs::constant" type wrapping and no additional parenthesis around the tag value.
    BOOST_LOG_SCOPED_THREAD_TAG("Tag", std::string, "Called from A::bar");

[warning When using scoped attributes, make sure that the scoped attribute is not altered in the attribute set in which it was registered. For example, one should not clear or reinstall attribute set of the logger if there are logger-specific scoped attributes registered in it. Otherwise the program will likely crash. This issue is especially critical in multithreaded application, when one thread may not know whether there are scoped attributes in the logger or there are not. Future releases may solve this limitation but currently the scoped attribute must remain intact until unregistered on leaving the scope.]

Although the described macros are intended to be the primary interface for the functionality, there is also a C++ interface available. It may be useful if user decides to develop his own macros that cannot be based on the existing ones.

Any scoped attribute is attached to a generic sentry object of type `scoped_attribute`. As long as the sentry exists, the attribute is registered. There are several functions that create sentries for source or thread-specific attributes:

    // Source-specific scoped attribute registration
    template< typename LoggerT >
    [unspecified] add_scoped_logger_attribute(
        LoggerT& l, typename LoggerT::string_type const& name, shared_ptr< attribute > const& attr);

    template< typename LoggerT, typename AttributeT >
    [unspecified] add_scoped_logger_attribute(
        LoggerT& l, typename LoggerT::string_type const& name, AttributeT& attr);

    // Thread-specific scoped attribute registration
    template< typename CharT >
    [unspecified] add_scoped_thread_attribute(std::basic_string< CharT > const& name, shared_ptr< attribute > const& attr);

    template< typename CharT, typename AttributeT >
    [unspecified] add_scoped_thread_attribute(std::basic_string< CharT > const& name, AttributeT& attr);

Please note that the overloads that accept references to the attribute do not control the life time of the attribute. These overloads can be used to temporarily register attributes that reside on stack or are members of a class - in other words, whose life duration is controlled elsewhere.

The object of `scoped_attribute` type is able to attach results of each of these functions on its construction. For example, `BOOST_LOG_SCOPED_LOGGER_ATTR(lg, "RunTime", attrs::timer)` can roughly be expanded to this:

    attrs::timer attr;
    attrs::scoped_attribute sentry = attrs::add_scoped_logger_attribute(lg, "RunTime", attr);

[endsect]

[section:rotating_ofstream Rotating file stream]

    #include <boost/log/utility/rotating_ofstream.hpp>

It is often convenient to split log into several parts in order to reduce log file sizes and make it more manageable. This functionality is implemented in the `basic_rotating_ofstream` class template (convenience typedefs `rotating_ofstream` and `rotating_wofstream` are also available). This stream is capable to dynamically change the underlying file the data written to. There are two supported criteria of rotation:

* The file can be rotated upon a certain file size. The maximum file size can be specified in the stream constructor or `open` method in the named argument `rotation_size`.

[note The rotation file size can be imprecise. The implementation counts the number of bytes written to the file, but the underlying API can introduce additional auxiliary data, which would increase the log file size on disk. The most well-known such case is the way Windows and DOS operating systems work with text files with regard to new-line characters. Each new-line character is written as a two byte sequence 0x0D 0x0A instead of a single 0x0A. There are other platforms known that introduce much more distortion into the written data.]

* The file can be rotated upon some time interval, which can be specified in the named argument `rotation_interval` as number of seconds.

These two criteria can be combined together, so it is possible, for instance, to rotate the log file each hour but keep its size under 1 MB.

Since the underlying file may change, the rotating stream accepts a file name template instead of the final file name. The file name may be composed of the current date and time (see formatting capabilities of __boost_date_time__ for placeholder description) and/or file counter (using the `%N` placeholder with optional `printf`-style format specifiers). A few quick examples:

[table
    [[Template]                            [Expands to]]
    [[file\_%N.log]                        [file\_1.log, file\_2.log...]]
    [[file\_%03N.log]                      [file\_001.log, file\_002.log...]]
    [[file\_%Y%m%d.log]                    [file\_20080705.log, file\_20080706.log...]]
    [[file\_%Y-%m-%d\_%H-%M-%S.%N.log]     [file\_2008-07-05\_13-44-23.1.log, file\_2008-07-06\_16-00-10.2.log...]]
]

The rotating stream is designed in order not to break log records in the middle when it comes to rotating the file. This feature needs the stream to know when a log record is ended and when the next one is started. Such requirement cannot be fulfilled with the standard stream interface. The `basic_rotating_ofstream` supports an additional interface `record_writer` that allows the stream to receive such metadata. However, this makes [_the rotating stream not a regular stream anymore, since it doesn't write data into the underlying file until it receives notifications that delimit log records]. The `record_writer` interface is also supported in the [link advanced.advanced.sink_backends.text_ostream text stream backend], so using the rotating stream with the sink just works. But if you ever use the rotating stream outside the library, you should make sure you provide the stream with this metadata.

Here's a basic usage example:

    void foo()
    {
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(
            new sinks::synchronous_sink< sinks::text_ostream_backend >);

        // The file will rotate every hour and will attempt not to exceed 1 MB.
        sink->locked_backend()->add_stream(boost::make_shared< rotating_ofstream >(
            "file_%02N.log", logging::keywords::rotation_interval = 3600, logging::keywords::rotation_size = 1048576));

        logging::core::get()->add_sink(sink);
    }

But there's more about the rotating file stream. The stream also supports calling user-defined functions before closing and after opening the underlying file. This can be very useful when the file should have a header and/or footer, like XML files, for example. With support of formatters, it is well possible to store log records in XML, like this:

    // The function is called for every file being opened
    void write_header(std::ostream& strm)
    {
        strm << "<?xml version=\"1.0\"?>\n"
                "<log>\n";
    }

    // The function is called for every file being closed
    void write_footer(std::ostream& strm)
    {
        strm << "</log>\n";
    }

    void foo()
    {
        // Construct the stream
        boost::shared_ptr< rotating_ofstream > strm(
            new rotating_ofstream("log_%02N.xml", logging::keywords::rotation_interval = 3600, logging::keywords::rotation_size = 1048576));

        // Setup open and close handlers
        strm->set_open_handler(&write_header);
        strm->set_close_handler(&write_header);

        // Create a sink
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(
            new sinks::synchronous_sink< sinks::text_ostream_backend >);
        sink->locked_backend()->add_stream(strm);

        // Setup the formatter
        sink->set_formatter(fmt::ostrm
            << "\t<message id=\"" << fmt::attr< unsigned int >("Line #") << "\">\n"
                << "\t\t<timestamp>" << fmt::date_time("TimeStamp") << "</timestamp>\n"
                << "\t\t<level>" << fmt::attr< int >("Severity") << "</level>\n"
                << "\t\t<![CDATA[" << fmt::message() << "]]>\n"
            << "\t</message>");

        logging::core::get()->add_sink(sink);
    }

[endsect]

[section:type_dispatch Type dispatchers]

    #include <boost/log/utility/type_dispatch/type_dispatcher.hpp>

Type dispatchers are used throughout the library in order to work with attribute values. Dispatchers allow to acquire actual typed attribute value using the Visitor concept. The most notable places where the functionality is used are filters and formatters. However, this mechanism is orthogonal to attributes and can be used for other purposes as well. Most of the time users won't need to dig into details of type dispatchers, but this information may be useful for the ones who intend to extend the library and wants to understand what's under the hood.

Every type dispatcher supports `type_dispatcher` interface. When an attribute value needs to be extracted, this interface is passed to the attribute value object, which then tries to acquire the concrete visitor for the actual type of the value. All visitors derive from the appropriate instance of the `type_visitor` class template, instantiated on the actual type of the value. If the dispatcher is capable to consume the value of the requested type, it must return the pointer to the appropriate visitor interface. Otherwise it returns `NULL`. When (and if) the corresponding visitor is acquired, the attribute value object only have to pass the contained value to the visitor.

Gladly, there is no need to write type dispatchers from scratch. The library provides two kinds of type dispatchers that implement `type_dispatcher` and `type_visitor` interfaces and encapsulate the visitor lookup.

[heading Static type dispatcher]

    #include <boost/log/utility/type_dispatch/static_type_dispatcher.hpp>

Static type dispatchers are used when the set of types that needs to be supported for extraction is known at compile time. The `static_type_dispatcher` class template is parametrized with an MPL type sequence of types that needs to be supported. The dispatcher inherits from `type_dispatcher` and `type_visitor` instances for all types in the MPL sequence. All you need to do is derive your class from the dispatcher and implement the `visit` methods for all supported types, like this:

    // A simple attribute value
    template< typename T >
    struct my_value :
        public logging::attribute_value
    {
        T m_Value;

        explicit my_value(T const& value) : m_Value(value) {}

        // The function passes the contained type into the dispatcher
        bool dispatch(logging::type_dispatcher& dispatcher)
        {
            logging::type_visitor< T >* visitor = dispatcher.get_visitor< T >();
            if (visitor)
            {
                visitor->visit(m_Value);
                return true;
            }
            else
                return false;
        }

        // Other functions omitted for brevity...
    };

    // Type dispatcher for the supported types
    struct my_dispatcher :
        public logging::static_type_dispatcher<
            boost::mpl::vector< int, double, std::string >
        >
    {
        // Implement visitation logic for all supported types
        void visit(int const& value)
        {
            std::cout << "Received int value = " << value << std::endl;
        }
        void visit(double const& value)
        {
            std::cout << "Received double value = " << value << std::endl;
        }
        void visit(std::string const& value)
        {
            std::cout << "Received string value = " << value << std::endl;
        }
    };

    int main(int, char*[])
    {
        my_dispatcher disp;

        // These two attributes are supported by the dispatcher
        my_value< std::string > val1("Hello world!");
        assert(val1.dispatch(disp));

        my_value< double > val2(1.2);
        assert(val2.dispatch(disp));

        // This one is not
        my_value< float > val3(-4.3);
        assert(!val3.dispatch(disp));

        return 0;
    }

[tip In the example above we implemented a reduced attribute value object. Since in most cases this implementation is always the same, the library provides a ready-to-go attribute value in the [headerref boost/log/attributes/basic_attribute_value.hpp ] file, the `basic_attribute_value` class template.]

Static type dispatcher also supports another way of use which allows to avoid code duplication if values of several types have to be processed in a similar manner. In the example above we wanted to print the dispatched value on the console, whatever it is. The same can be achieved with templated metafunction class which is injected into the dispatcher as a visitor.

    // The templated visitor will be instantiated on every type supported by the dispatcher
    template< typename T >
    struct my_visitor :
        public logging::type_visitor< T >
    {
        void visit(T const& value)
        {
            std::cout << "Received " << typeid(T).name() << " value = " << value << std::endl;
        }
    };

    // Type dispatcher for the supported types
    typedef logging::static_type_dispatcher<
        boost::mpl::vector< int, double, std::string >,
        boost::mpl::quote1< my_visitor >
    > my_dispatcher;

This dispatcher can be used precisely the same way as the previously defined one. Note also that __boost_mpl__ lambda expressions are also supported as visitor generators.

[tip See also [link advanced.advanced.utilities.extractors attribute value extractors] for an even simpler solution if all you want is to get an attribute value.]

[heading Dynamic type dispatcher]

    #include <boost/log/utility/type_dispatch/dynamic_type_dispatcher.hpp>

In case if the set of types that have to be supported is not available at compile time, the `dynamic_type_dispatcher` class to help. One can use its `register_type` method to add support for a particular type. User has to pass a function object along with the type, this functor will be called when a visitor for the specified type is invoked. Considering the `my_value` from the code sample for static type dispatcher is intact, the code can be rewritten as follows:

    // Implement visitation logic for all supported types
    void on_int(int const& value)
    {
        std::cout << "Received int value = " << value << std::endl;
    }
    void on_double(double const& value)
    {
        std::cout << "Received double value = " << value << std::endl;
    }
    void on_string(std::string const& value)
    {
        std::cout << "Received string value = " << value << std::endl;
    }

    int main(int, char*[])
    {
        logging::dynamic_type_dispatcher disp;

        // Register type visitors
        disp.register_type< int >(&on_int);
        disp.register_type< double >(&on_double);
        disp.register_type< std::string >(&on_string);

        // These two attributes are supported by the dispatcher
        my_value< std::string > val1("Hello world!");
        assert(val1.dispatch(disp));

        my_value< double > val2(1.2);
        assert(val2.dispatch(disp));

        // This one is not
        my_value< float > val3(-4.3);
        assert(!val3.dispatch(disp));

        return 0;
    }

Of course, complex function objects, like provided by __boost_bind__, are also supported.

[endsect]

[section:predef_types Predefined type sequences]

    #include <boost/log/utility/type_dispatch/standard_types.hpp>
    #include <boost/log/utility/type_dispatch/date_time_types.hpp>

One may notice that when using type dispatchers and defining filters and formatters it may be convenient to have some predefined type sequences to designate frequently used sets of types. The library provides several such sets.

[table Standard types (standard_types.hpp)
    [[Type sequence]                            [Meaning]]
    [[`integral_types`]                         [All integral types, including `bool`, character and 64 bit integral types, if available]]
    [[`floating_point_types`]                   [Floating point types]]
    [[`numeric_types`]                          [Includes `integral_types` and `floating_point_types`]]
    [[`string_types` and `wstring_types`]       [Narrow or wide string types. Currently only includes STL string types and [link advanced.advanced.utilities.string_literal string literals].]]
]

There are also a number of time-related type sequences available:

[table Time-related types (date_time_types.hpp)
    [[Type sequence]                            [Meaning]]
    [[`native_date_time_types`]                 [All types defined in C/C++ standard that have both date and time portions]]
    [[`boost_date_time_types`]                  [All types defined in __boost_date_time__ that have both date and time portions]]
    [[`date_time_types`]                        [Includes `native_date_time_types` and `boost_date_time_types`]]
    [[`native_date_types`]                      [All types defined in C/C++ standard that have date portion. Currently equivalent to `native_date_time_types`.]]
    [[`boost_date_types`]                       [All types defined in __boost_date_time__ that have date portion]]
    [[`date_types`]                             [Includes `native_date_types` and `boost_date_types`]]
    [[`native_time_types`]                      [All types defined in C/C++ standard that have time portion. Currently equivalent to `native_date_time_types`.]]
    [[`boost_time_types`]                       [All types defined in __boost_date_time__ that have time portion. Currently equivalent to `boost_date_time_types`.]]
    [[`time_types`]                             [Includes `native_time_types` and `boost_time_types`]]
    [[`native_time_duration_types`]             [All types defined in C/C++ standard that are used to represent time duration. Currently only includes `double`, as the result type of the `difftime` standard function.]]
    [[`boost_time_duration_types`]              [All time duration types defined in __boost_date_time__]]
    [[`time_duration_types`]                    [Includes `native_time_duration_types` and `boost_time_duration_types`]]
    [[`boost_time_period_types`]                [All time period types defined in __boost_date_time__]]
    [[`time_period_types`]                      [Currently equivalent to `boost_time_period_types`]]
]

[endsect]

[section:extractors Attribute value extractors]

    #include <boost/log/utility/attribute_value_extractor.hpp>

Attribute value extractors serve as a helper tool on top of [link advanced.advanced.utilities.type_dispatch type dispatchers] in order to simplify extracting attribute values in generic code. The functionality is implemented in the `attribute_value_extractor` class template, parametrized on character type and type or MPL sequence of types that have to be supported for dispatch. The `attribute_value_extractor` instance is a binary functional object that accepts a set of attribute values and another functional object that will receive the extracted attribute value. The name of the attribute to be extracted is given as the constructor argument to the extractor. The key advantage of using extractors instead of raw dispatchers is that the receiving functional object may have a template `operator ()`. Obviously, this allows to reduce the amount of code in case of similar processing of attributes of different types. For example:

    // A generic function object that outputs attribute value
    struct print_attribute_value
    {
        typedef void result_type;

        // This operator will be instantiated for all possible types of the attribute value
        template< typename T >
        void operator() (T const& value) const
        {
            std::cout << "Received " << logging::type_info_wrapper(typeid(T)).pretty_name()
                << " attribute value: " << value << std::endl;
        }
    };

    void foo(attribute_values_view const& attrs)
    {
        // Let's assume we want to output value of attribute "MyAttr" that may have any numeric type
        logging::attribute_value_extractor< char, logging::numeric_types > extractor1("MyAttr");
        assert(extractor1(attrs, print_attribute_value()));

        // The extractor returns false if it is unable to extract the value
        logging::attribute_value_extractor< char, std::complex< double > > extractor2("MyAttr");
        assert(!extractor2(attrs, print_attribute_value()));
    }

Note that predefined type sequences provided by the library can be used freely with extractors just as well as with filters and formatters. Also note that specifying a single type of the attribute value instead of type sequence is also perfectly valid.

[endsect]


[section:init Simplified library initialization tools]

This part of the library is provided in order to simplify logging initialization and provide basic tools to develop user-specific initialization mechanisms. It is known that setup capabilities and preferences may vary widely from application to application, therefore the library does not attempt to provide a universal solution for this task. The provided tools are mostly intended to serve as a quick drop-in support for logging setup and a set of instruments to implement something more elaborate and more fitting user's needs.

[heading Convenience functions]

    #include <boost/log/utility/init/to_console.hpp>
    #include <boost/log/utility/init/to_file.hpp>
    #include <boost/log/utility/init/common_attributes.hpp>

The library provides a number of functions that simplify some common initialization procedures, like sink and commonly used attributes registration. This is not much of a functionality, however, it allows to save a couple of minutes of learning the library for a newcomer.

Logging to the application console is the simplest way to see the logging library in action. To achieve this, one can initialize the library with a single function call, like this:

    int main(int, char*[])
    {
        // Initialize logging to std::clog
        logging::init_log_to_console();

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Pretty easy, isn't it? There is `winit_log_to_console` function for wide-character logging. If you want to put logs to some other standard stream, you can pass the stream to the `init_log_to_console` function as an argument. E.g. enabling logging to `std::cout` instead of `std::clog` would look like this:

    logging::init_log_to_console(std::cout);

What's important, is that you can further manage the console sink if you save the `shared_ptr` to the sink that this function returns. This allows you to setup things like filter, formatter and auto-flush flag.

    int main(int, char*[])
    {
        // Initialize logging to std::clog
        boost::shared_ptr<
            sinks::synchronous_sink< sinks::text_ostream_backend >
        > sink = logging::init_log_to_console();

        sink->set_filter(flt::attr< int >("Severity") >= 3);
        sink->locked_backend()->auto_flush(true);

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Similarly to console, one can use a single function call to enable logging to a file. All you have to do is to provide the file name:

    int main(int, char*[])
    {
        // Initialize logging to the "test.log" file
        logging::init_log_to_file("test.log");

        // Here we go, we can write logs right away
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

Like with `init_log_to_console`, the `init_log_to_file` function has its wide-character counterpart `winit_log_to_file` and returns the `shared_ptr` to the registered sink. The functions do not conflict and may be combined freely, so it is possible to setup logging to console and a couple of files, including filtering and formatting, in about 10 lines of code.

Lastly, there is a `add_common_attributes` function that registers two most frequently used attributes: "LineID" and "TimeStamp". The former counts log record being made and has attribute value `unsigned int`. The latter, as its name implies, provides current time for each log record, in form of `boost::posix_time::ptime` (see __boost_date_time__). These two attributes are registered globally, so they will remain available in all threads and loggers. This makes the final version of our code sample to look something like this:

    int main(int, char*[])
    {
        // Initialize sinks
        logging::init_log_to_console()->set_filter(flt::attr< int >("Severity") >= 4);

        boost::function< void (std::ostream&, attribute_values_view const&, std::string const&) > formatter =
            fmt::ostrm
                << fmt::attr< unsigned int >("LineID", "[% 9u] ")
                << fmt::date_time< boost::posix_time::ptime >("TimeStamp") << " *"
                << fmt::attr< int >("Severity") << "* " << fmt::message();

        logging::init_log_to_file("complete.log")->locked_backend()->set_formatter(formatter);

        boost::shared_ptr<
            sinks::synchronous_sink< sinks::text_ostream_backend >
        > sink = logging::init_log_to_file("essential.log");
        sink->locked_backend()->set_formatter(formatter);
        sink->set_filter(flt::attr< int >("Severity") >= 1);

        // Register common attributes
        logging::add_common_attributes();

        // Here we go, we can write logs
        src::logger lg;
        BOOST_LOG(lg) << "Hello world!";

        return 0;
    }

[heading Filter and formatter parsers]

    #include <boost/log/utility/init/filter_parser.hpp>
    #include <boost/log/utility/init/formatter_parser.hpp>

Filter and formatter parsers allow to construct filters and formatters from a descriptive string. The function `parse_filter` is responsible for recognizing filters and `parse_formatter` - for recognizing formatters.

In case of filters the string is formed of a sequence of condition expressions, interconnected with boolean operations. There are two operations supported: conjunction (designated as "&" or "and") and disjunction ("|" or "or"). Each condition itself may be either a single condition or a sub-filter, taken in round brackets. Each condition can be negated with the "!" sign or "not" keyword. The condition, if it's not a sub-filter, usually consists of an attribute name enclosed in percent characters ("%"), a relation keyword and an operand. The relation and operand may be omitted, in which case the condition is assumed to be the requirement of the attribute presence (with any type).

[pre
filter:
    condition { op condition }

op:
    &
    and
    |
    or

condition:
    !condition
    not condition
    (filter)
    %attribute_name%
    %attribute_name% relation operand

relation:
    >
    <
    =
    !=
    >=
    <=
    begins_with
    ends_with
    contains
    matches
]

Below are some examples of filters:

[table Examples of filters
[[Filter string]                    [Description]]
[[`%Severity%`]                     [The filter returns `true` if an attribute value with name "Severity" is found in a log record.]]
[[`%Severity% > 3`]                 [The filter returns `true` if an attribute value with name "Severity" is found and it is greater than 3. The attribute value must be of one of the [link advanced.advanced.utilities.predef_types integral types].]]
[[!(`%Ratio% > 0.0 & %Ratio% <= 0.5)`] [The filter returns `true` if an attribute value with name "Ratio" of one of the [link advanced.advanced.utilities.predef_types floating point types] is not found or it is not between 0 and 0.5.]]
[[`%Tag% contains "net" or %Tag% contains "io" and not %StatFlow%`] [The filter returns `true` if an attribute value with name "Tag" is found and contains words "net" or "io" and if an attribute value "StatFlow" is not found. The "Tag" attribute value must be of one of the [link advanced.advanced.utilities.predef_types string types], the "StatFlow" attribute value type is not considered.]]
]

The formatter string syntax is even simpler and pretty much resembles __boost_format__ format string syntax. The string must contain attribute names enclosed in percent signs ("%"), the corresponding attribute value will replace these placeholders. The placeholder "%\_%" is special, it will be replaced with the log record text. For instance, `[%TimeStamp%] *%Severity%* %_%` formatter string will make log records look like this: `[2008-07-05 13:44:23] *0* Hello world`.

You may have noticed that the formatters don't provide means to change the formatting rules of attribute values. This can be changed on a per-attribute basis by registering custom formatters. Having done this, the `parse_formatter` function will use a user-defined function to create the correct formatter. Furthermore, it is possible to pass named arguments to the function from the formatter string, the arguments must be specified in round brackets, separated with commas, right after the attribute name. Here is an example:

    // The function constructs the appropriate formatter
    logging::formatter_types< char >::formatter_type time_stamp_formatter_factory(
        std::string const& attr_name, logging::formatter_types< char >::formatter_factory_args const& formatter_args)
    {
        // Find the "format" argument
        typedef logging::formatter_types< char >::formatter_factory_args args;
        args::const_iterator it = formatter_args.find("format");
        if (it != formatter_args.end())
        {
            return fmt::date_time< boost::posix_time::ptime >(attr_name, fmt::keywords::format = it->second);
        }
        else
        {
            return fmt::date_time< boost::posix_time::ptime >(attr_name);
        }
    }

    int main(int, char*[])
    {
        // Register the formatter for the "TimeStamp" attribute
        logging::register_formatter_factory("TimeStamp", &time_stamp_formatter_factory);

        // Log records will look like this: "[23.05.2008 17:23:16] Hello world"
        logging::formatter_types< char >::formatter_type fmt = logging::parse_formatter(
            "[%TimeStamp(format=\"%d.%m.%Y %H:%M:%S\")%] %_%")

        // ...

        return 0;
    }

Such custom formatters are required to be registered for all attributes whose types are not known to the library (see [link advanced.advanced.utilities.predef_types which types are known]), if their formatting needs to be supported.

[note The parsed formatters and filters are generally less optimal than the equivalent ones written in code. This is because of two reasons: (\*) the programmer usually knows more about types of the attribute values that may be involved in formatting or filtering and (\*) the compiler has a better chance to optimize the formatter or filter if it is known in compile time. Therefore, if the performance matters, it is advised to avoid parsed filters and formatters.]

[heading Library initialization from a settings file]

    #include <boost/log/utility/init/from_stream.hpp>

Support for configuration files is a frequently requested feature of the library. And despite the fact there is no ultimately convenient and flexible format of the library settings, the library supports this feature. The functionality is implemented with a simple function `init_from_stream`, which accepts an STL input stream and reads the library settings from it.

The settings format is quite simple and widely used. Below is the description of syntax and parameters.

[pre
\# Comments are allowed. Comment line begins with the '\#' character and spans until the end of the line.

\# Logging core settings section. May be omitted if no parameters specified within it.
\[Core\]

\# Enables or disables logging completely. May have values 0 or 1. Optional, default value is 0.
DisableLogging\=0

\# Global filter. Optional, by default no filter is applied.
Filter\="%Severity% > 3"


\# Sink settings sections. There may be arbitrary number of such sections. It is essential that the sink section name
\# begins with the "Sink:" prefix. The rest of the section name is not relevant and is used for convenience and making
\# section names unique.
\[Sink:MySink1\]

\# Sink destination type. Mandatory, can have one of the following values: Console, TextFile, Syslog.
\# The Syslog can be not supported on some platforms.
Destination\=Console

\# Sink-specific filter. Optional, by default no filter is applied.
Filter\="%Target% contains "MySink1""

\# Formatter string. Optional, by default only log record message text is written.
Format\="<%TimeStamp%> - %\_%"

\# The flag shows whether the sink should be asynchronous. May have values 0 or 1. Optional, default value is 0.
\# Not used in single-threaded builds.
Asynchronous\=0

\# Specific for Console and TextFile sinks. Enables automatic stream flush after each log record.
\# May have values 0 or 1. Optional, default value is 0.
AutoFlush\=0

\# Specific for TextFile sink. Log file name or name template. Mandatory.
FileName\="test\_%N%.log"

\# Specific for TextFile sink. Log file rotation size, in bytes. Optional, by default no rotation on size is performed.
RotationSize\=65536

\# Specific for TextFile sink. Log file rotation interval, in seconds. Optional, by default no rotation on time interval is performed.
RotationInterval\=3600
]

The library also supports registering user-defined sinks in order to be supported with the settings file. User has to pass the sink initializing functor with his sink destination type string to the `register_sink_factory` function. The `init_from_stream` function will invoke it when it encounters the specified destination type. The contents of the sink section of parameters will be passed to the functor.

    // The function reads parameters from the settings section and creates the custom sink
    shared_ptr< sinks::sink< char > > construct_my_sink(std::map< std::string, std::string > const& args)
    {
        std::map< std::string, std::string >::const_iterator it = args.find("Param");
        if (it != args.end())
        {
            // ...
        }

        // ...

        return sink;
    }

    int main(int, char*[])
    {
        // Now all sections with Destination=MySink will be constructed in construct_my_sink
        logging::register_sink_factory("MySink", &construct_my_sink);

        std::ifstream file("settings.ini");
        logging::init_from_stream(file);

        return 0;
    }

[endsect]

[endsect]

[endsect]
