[library Boost.Log
    [quickbook 1.3]
    [authors [Semashev, Andrey]]
    [copyright 2007, 2008 Andrey Semashev]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt]).
    ]
    [id log]
    [source-mode c++]
    [last-revision $Date: 2008-07-02 19:08:48 $]
]

[c++]

[def __boost_smart_ptr__ [@http://www.boost.org/doc/libs/release/libs/smart_ptr/smart_ptr.htm Boost.SmartPtr]]
[def __boost_function__ [@http://www.boost.org/doc/libs/release/doc/html/function.html Boost.Function]]
[def __boost_filesystem__ [@http://www.boost.org/doc/libs/release/libs/filesystem/doc/index.htm Boost.Filesystem]]
[def __boost_system__ [@http://www.boost.org/doc/libs/release/libs/system/doc/index.html Boost.System]]
[def __boost_date_time__ [@http://www.boost.org/doc/libs/release/doc/html/date_time.html Boost.DateTime]]
[def __boost_thread__ [@http://www.boost.org/doc/libs/release/doc/html/thread.html Boost.Thread]]
[def __boost_regex__ [@http://www.boost.org/doc/libs/release/libs/regex/index.html Boost.Regex]]
[def __boost_xpressive__ [@http://www.boost.org/doc/libs/release/doc/html/xpressive.html Boost.Xpressive]]
[def __boost_parameter__ [@http://www.boost.org/doc/libs/release/libs/parameter/doc/html/index.html Boost.Parameter]]
[def __boost_format__ [@http://www.boost.org/doc/libs/release/libs/format/index.html Boost.Format]]
[def __boost_preprocessor__ [@http://www.boost.org/doc/libs/release/libs/preprocessor/doc/index.html Boost.Preprocessor]]
[def __boost_bind__ [@http://www.boost.org/doc/libs/release/libs/bind/bind.html Boost.Bind]]
[def __boost_lambda__ [@http://www.boost.org/doc/libs/release/doc/html/lambda.html Boost.Lambda]]
[def __boost_phoenix__ [@http://www.boost.org/doc/libs/release/libs/spirit/doc/phoenix.html Boost.Phoenix]]
[def __boost_optional__ [@http://www.boost.org/doc/libs/release/libs/optional/index.html Boost.Optional]]
[def __boost_intrusive__ [@http://www.boost.org/doc/libs/release/doc/html/intrusive.html Boost.Intrusive]]
[def __boost_iostreams__ [@http://www.boost.org/doc/libs/release/libs/iostreams/doc/index.html Boost.IOStreams]]

[section Disclaimer]

This library is not an official part of [@http://www.boost.org Boost libraries collection] although it is aimed to be proposed for inclusion at some point.

[endsect]

[section:moti Motivation]

Today applications grow rapidly, becoming complicated and difficult to test and debug. Most of the time applications run on a remote site, leaving the developer little chance to monitor its execution and figure out the reason of its failure, once it should happen. Moreover, even the local debugging may become problematic if the application behavior depends heavilly on asynchronous third-party events, like device feedback or another process activity.

This is where logging may help. The application stores all essential information of its run time to log, and once something goes wrong this information can be used to analyse program behavior and make necessary corrections. There are other very useful applications of logging, such as gathering statistic information and alarming (i.e. indicating that the application is experiencing some problems). These tasks have proven to be vital for many real-world industrial applications.

This library aims to make logging significantly easier for the application developer. It provides a wide range of out-of-box tools, along with public interfaces ready to be used to extend the library. The main goals of the library are:

* Simplicity. A small example code snippet should be enough to get the feel of the library and be ready to use its basic features.
* Extensibility. A user should be able to extend library's functionality in ways of collecting and storing information into logs.
* Performance. The library should make as least performance impact on the user's application as possible.

[endsect]

[section:defs Definitions]

Here are definitions of some terms that will be used widely throughout the documentation:

[variablelist
    [[Log record][A single pack of information, collected from the user's application, that is candidate to be put in log. In a simple case the log record will be represented as a line of text in the log file after being processed by the logging library.]]
    [[Log attribute][An "attribute" is basically a piece of information of which the logging record consists. Attributes may have different types (integers, strings and more complex, including user defined types). Some examples of attributes: current time stamp, file name, line number, current scope name, etc..]]
    [[Log sink][A target, to which all log records are fed after being collected from user's application. It is sink's nature that defines where and how the log is going to be stored.]]
    [[Log source][An entry point for user's application to put log records to. In a simple case it is an object (logger) which maintains a set of attributes that will form a log record upon user's request. Hovewer, one can surely create a source that would emit log records on some third-party events (for example, by intercepting another application's console output).]]
    [[Log filter][A predicate that takes a log record and tells weither this record should be passed through or discarded.]]
    [[Log formatter][A functional object that forms up the final shape of the output. Some sinks, like binary logging sink, may not need it although almost any text-based sink would use a formatter to compose its output.]]
    [[Logging core][The global entity that maintains connection between sources and sinks and applies filters to records. It is mainly used on the logging library initialization stage.]]
    [[i18n][Internationalization. The ability to manipulate wide characters.]]
]

[endsect]

[section:how_to_read How to read the documentation]

The documentation is oriented to both newbies and experienced library users. However, users are expected to be familiar with the commonly used Boost components, such as `shared_ptr`, `make_shared` (see __boost_smart_ptr__), and `function` (__boost_function__). Some parts of the documentation will refer to other Boost libraries as needed.

If this is your first experience with the library, it is recommended to read the [link log.installation Instalation] and [link tutorial.tutorial Tutorial] sections first. The tutorial gives the overview of the library features with sample code snippets. Some tutorial steps are presented in two forms: simple and advanced. The simple form typically describes the most common and easy way to do the task and it is being recommended to be read by newbies. The advanced form usually gives an expanded way to do the same thing but with ability to do some extra customization. It also often explains the library features behind the simple interface in a more detailed way. This form may come handy for more experienced users and should generally be read if your needs are not satisfied with the easy way.

Besides the tutorial there is an [link log.advanced Advanced features] chapter. This part gives description of other tools provided by the library that were not covered by the tutorial. This chapter is better to be read on per-case basis.

Last, but not least, there is a reference which gives the formal description of library components.

For simplicity in the code snippets in this documentation it shall be assumed that the following namespace aliases were defined:

    namespace logging = boost::log;
    namespace sinks = boost::log::sinks;
    namespace src = boost::log::sources;
    namespace fmt = boost::log::formatters;
    namespace flt = boost::log::filters;
    namespace attrs = boost::log::attributes;

[endsect]

[section:supported_compilers Supported compilers]

The library should build and work with a reasonably well-compliant compiler. The library was successfully built and tested on the following platforms:

* Windows XP, Windows Vista. MSVC 8.0, 9.0. MSVC 7.1 should work too, but it was not tested.
* Linux. GCC 4.2, 4.3. However, all GCC 4.x should work well.

The following compilers are not supported and will likely fail to compile the library:

* MSVC 7.0 and older.
* Borland C++ 5.5.1 (free version). Newer versions might or might not work.
* GCC 3.3 and older.

[endsect]

[section:installation Installation]

The library has the compiled part which should be built as described in the [@http://www.boost.org/doc/libs/release/more/getting_started/ Getting Started] article. One thing should be noted, though. If your aplication consists of more than one module (e.g. an exe and one or several dll's) the library _must_ be built as a shared object. If you have a single executable, you may build the library as a static library.

The library supports a number of configuration macros:

[table Configuration macros
    [[Macro name]                               [Effect]]
    [[`BOOST_LOG_DYN_LINK`]                     [If defined in user code, the library will assume the binary is built as a dynamically loaded library (dll or so). Otherwise it is assumed that the library is built in static mode. This macro must be either defined or not defined for all translation units of user application that use logging. This macro can help with auto-linking on platforms that support it.]]
    [[`BOOST_ALL_DYN_LINK`]                     [Same as `BOOST_LOG_DYN_LINK` but also affects other Boost libraries the same way]]
    [[`BOOST_LOG_NO_THREADS`]                   [If defined, disables multithreading support. Has effect on both the library compilation and user code compilation.]]
    [[`BOOST_LOG_USE_CHAR`]                     [If defined, enables support for narrow character logging. Has effect on both the library compilation and user code compilation.]]
    [[`BOOST_LOG_USE_WCHAR_T`]                  [If defined, enables support for wide character logging. Has effect on both the library compilation and user code compilation. If neither `BOOST_LOG_USE_CHAR` nor `BOOST_LOG_USE_WCHAR_T` is defined, it is assumed the both character types support is enabled. Defining only one of them allows to significantly reduce binary size of the library.]]
    [[`BOOST_LOG_NO_QUERY_PERFORMANCE_COUNTER`] [Has effect on Windows platform only, on both the library compilation and user code compilation stages. If defined, disables support for `QueryPerformanceCounter` API in the `timer` attribute. This will result in a significantly less accurate time readings and may reduce performance a little. The macro is intended to solve possible problems with earlier revisions of AMD Athlon CPU, described [@http://support.microsoft.com/?scid=kb;en-us;895980 here] and [@http://support.microsoft.com/?id=896256 here].]]
    [[`BOOST_LOG_USE_NATIVE_SYSLOG`]            [Has effect on the library compilation stage. If for some reason the support for native SysLog API is not detected, define this macro to enable support for SysLog.]]
]

You may define configuration macros in the `bjam` command line, like this:

[pre
    bjam --with-log variant=release define=BOOST_LOG_USE_CHAR stage
]

The logging library also uses several Boost libraries that need building too. These are __boost_filesystem__, __boost_system__, __boost_date_time__, __boost_thread__ and __boost_regex__. Refer to their documentation for detailed instructions on building procedure.

[endsect]

[include:tutorial tutorial.qbk]
[include:advanced advanced.qbk]
[include:extension extension.qbk]

[section:rationale Rationale]

[section:why_str_lit Why string literals as scope names?]

One may wonder why not to allow to use arbitraty strings as named scope names. The answer is simple: for performance and safety reasons. Named scope support functionality has one significant difference from other attribute-related features of the library. The scope stack is maintained even when no logging is done, so if a function `foo` has a `BOOST_LOG_FUNCTION()` statement in its body, it is always a slowdown. Allowing the scope name to be an arbitrary string would make slowdown significantly greater because of the need to dynamically allocate memory and copy the string (not to say there would be a need to previously format it, which also takes its toll).

Dynamic memory allocation also introduces exception safety issues: the `BOOST_LOG_FUNCTION()` statement (and alikes) will become a potential source of exception. These issues would complicate user's code if he wants to solve memory allocation problems gracefully.

One possible alternative solution would be pooling preformatted and preallocated scope names somewhere but this would surely degrade performance even more and introduce the problem of detecting when to update or free pooled strings.

Therefore restricting to string literals seems the optimal desicion, which minimizes dynamic memory usage and provides enough flexibility for common needs.

[endsect]

[section:why_weak_scoped_attributes Why scoped attributes don't override existing attributes?]

Initially scoped attributes were able to override other attributes with the same name if they were already registered by the time when a scoped attribute encountered. This allowed some interesting use cases like this:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

    void foo()
    {
        // This scoped attribute would temporarily replace the existing tag
        BOOST_LOG_SCOPED_THREAD_TAG("Section", std::string, "In foo");

        // This log record will have a "Section" attribute with value "In foo"
        BOOST_LOG(get_my_logger()) << "We're in foo section";
    }

    int main(int, char*[])
    {
        BOOST_LOG_SCOPED_THREAD_TAG("Section", std::string, "In main");

        // This log record will have a "Section" attribute with value "In main"
        BOOST_LOG(get_my_logger()) << "We're in main section";

        foo();

        // This log record will have a "Section" attribute with value "In main" again
        BOOST_LOG(get_my_logger()) << "We're in main section again";

        return 0;
    }

However, this feature introduced a number of safety problems, including thread safety issues, that might be difficult to locate. For example, it was no longer safe to use logger-wide scoped attributes on the same logger from different threads, because the resulting attribute would be undefined:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

    void thread1()
    {
        BOOST_LOG_SCOPED_LOGGER_TAG(get_my_logger(), "Tag", std::string, "thread1");
        BOOST_LOG(get_my_logger()) << "We're in thread1";
    }

    void thread2()
    {
        BOOST_LOG_SCOPED_LOGGER_TAG(get_my_logger(), "Tag", int, 10);
        BOOST_LOG(get_my_logger()) << "We're in thread2";
    }

    int main(int, char*[])
    {
        BOOST_LOG_SCOPED_LOGGER_TAG(get_my_logger(), "Tag", double, -2.2);

        BOOST_LOG(get_my_logger()) << "We're in main";

        boost::thread t1(&thread1);
        boost::thread t2(&thread2);

        t1.join();
        t2.join();

        // Which "Tag" is registered here?
        BOOST_LOG(get_my_logger()) << "We're in main again";

        return 0;
    }

There were other issues, like having an attribute set iterator that points to one attribute object, then suddenly without seemingly modifying it it becomes to point to a different attribute object (of, possibly, a different type). Such behavior could lead to tricky failures that would be difficult to investigate. Therefore this feature was eventually dropped, which simplified scoped attributes implementation significantly.

[endsect]

[endsect]

[xinclude autodoc.xml]

[section:todo TODO in future releases]

* Optimize scoped attributes. The idea is to store both the attribute and the `shared_ptr` counter on the stack. Currently only the attribute is stored on the stack.
* Optimize single-threaded configuration. In many places dynamic memory allocation can be removed if multithreading support is disabled.
* Support C++0x features, like variadic templates.
* Optionally support [@http://www.threadingbuildingblocks.org Intel TBB]. In particular, atomic types and thread-safe queue could be useful.
* Move from __boost_regex__ to __boost_xpressive__. This would remove the dependency in the Boost.Regex library module. However, Boost.Regex support should be retained.
* Windows NT event log support. For now it is not clear how the support should be implemented. The problem is that event log API expects the user to supply a message ID rather than the message text. There is no problem to put the ID in an attribute, but that makes the formatted message text pretty much useless. Also, to make the event log backend generic enough, there must be some mapping between logging library attributes, event attributes and message IDs.

[endsect]

[section:acknowledgements Acknowledgements]

* Luca Rigini wrote the initial implementation of the NT event log sink and made a lot of suggestions on how to improve the library in regard of writing user-defined sinks.
* Jean-Daniel Michaud, Michael Lacher and all others who took part in the discussion of the requirements to the library on [@http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Boost.Logging Wiki].
* John Torjo, Gennadiy Rozental and others for their discussion on the John's logging library on the Boost developers list. It helped a lot to learn the requirements and possible solutions for the library.
* All authors of the great Boost libraries that were involved in this library (notably, __boost_smart_ptr__, __boost_thread__, __boost_function__, __boost_optional__, __boost_date_time__, __boost_filesystem__, __boost_intrusive__, __boost_iostreams__ and other).

[endsect]
