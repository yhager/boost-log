[library Boost.Log
    [quickbook 1.3]
    [authors [Semashev, Andrey]]
    [copyright 2007 Andrey Semashev]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt]).
    ]
    [id log]
    [last-revision $Date: 2008-05-18 12:16:43 $]
]

[c++]

[section Disclaimer]

This library is not an official part of [@http://www.boost.org Boost libraries collection] although it is aimed to be proposed for inclusion at some point.

[endsect]

[section:moti Motivation]

Today applications grow rapidly, becoming complicated and difficult to test and debug. Most of the time applications run on a remote site, leaving the developer little chance to monitor its execution and figure out the reason of its failure, once it should happen. Moreover, even the local debugging may become problematic if the application behavior depends heavilly on asynchronous third-party events, like device feedback or another process activity.

This is where logging may help. The application stores all essential information of its run time to log, and once something goes wrong this information can be used to analyse program behavior and make necessary corrections. There are other very useful applications of logging, such as gathering statistic information and alarming (i.e. indicating that the application is experiencing some problems). These tasks have proven to be vital for many real-world industrial applications.

This library aims to make logging significantly easier for the application developer. It provides a wide range of out-of-box tools, along with public interfaces ready to be used to extend the library. The main goals of the library are:

* Simplicity. A small example code snippet should be enough to get the feel of the library and be ready to use its basic features.
* Extensibility. A user should be able to extend library's functionality in ways of collecting and storing information into logs.
* Performance. The library should make as least performance impact on the user's application as possible.

[endsect]

[section:defs Definitions]

Here are definitions of some terms that will be used widely throughout the documentation:

* Log record. A single pack of information, collected from the user's application, that is candidate to be put in log. In a simple case the log record will be represented as a line of text in the log file after being processed by the logging library.
* Log attribute. An "attribute" is basically a piece of information of which the logging record consists. Attributes may have different types (integers, strings and more complex, including user defined types). Some examples of attributes: current time stamp, file name, line number, current scope name, etc..
* Log sink. A target, to which all log records are fed after being collected from user's application. It is sink's nature that defines where and how the log is going to be stored.
* Log source. An entry point for user's application to put log records to. In a simple case it is an object (logger) which maintains a set of attributes that will form a log record upon user's request. Hovewer, one can surely create a source that would emit log records on some third-party events (for example, by intercepting another application's console output).
* Log filter. A predicate that takes a log record and tells weither this record should be passed through or discarded.
* Log formatter. A functor that forms up the final shape of the output. Some sinks, like binary logging sink, may not need it although almost any text-based sink would use a formatter to compose its output.
* Logging core. The global entity that maintains connection between sources and sinks and applies filters to records. It is mainly used on the logging library initialization stage.
* i18n. Internationalization. The ability to manipulate wide characters.

[endsect]

[section:how_to_read How to read the documentation]

The documentation is oriented to both newbies and experienced library users. However, users are expected to be familiar with the commonly used Boost components, such as `shared_ptr`, `make_shared` (see [@http://www.boost.org/doc/libs/release/libs/smart_ptr/smart_ptr.htm Boost.SmartPtr]), and `function` ([@http://www.boost.org/doc/libs/release/doc/html/function.html Boost.Function]). Some parts of the documentation will refer to other Boost libraries as needed.

If this is your first experience with the library, it is recommended to read the [link log.installation Instalation] and [link log.tutorial Tutorial] sections first. The tutorial gives the overview of the library features with sample code snippets. Some tutorial steps are presented in two forms: easy and advanced. The easy form typically describes the most common and simple way to do the task and it is being recommended to be read by newbies. The advanced form usually gives an expanded way to do the same thing but with ability to do some extra customization. It also often explains the library features behind the easy interface in a more detailed way. This form may come handy for more experienced users and should generally be read if your needs are not satisfied with the easy way.

Besides the tutorial there is an [link advanced Advanced features] chapter. This part gives description of other tools provided by the library that were not covered by the tutorial. This chapter is better to be read on per-case basis.

Last, but not least, there is a reference which gives the formal description of library components.

For simplicity in the code snippets in this documentation it shall be assumed that the following namespace aliases were defined:

    namespace logging = boost::log;
    namespace sinks = boost::log::sinks;
    namespace src = boost::log::sources;
    namespace fmt = boost::log::formatters;
    namespace flt = boost::log::filters;
    namespace attrs = boost::log::attributes;

[endsect]

[section:installation Installation]

The library has the compiled part which should be built as described in the [@http://www.boost.org/doc/libs/release/more/getting_started/ Getting Started] article. One thing should be noted, though. If your aplication consists of more than one module (e.g. an exe and one or several dll's) the library *must* be built as a shared object. If you have a single executable, you may build the library as a static lib.

[endsect]

[section:tutorial Tutorial]

In this section we shall walk through the essential steps to get started with the library. After reading this part you should be able to initialize the library and add logging to your application. The code of this tutorial is also available in a single example resided in the `libs/log/examples/basic_usage` directory. You may feel free to play around with it, compile and see the result.

[section:tutorial_1 Step 1: Picking sinks]

[section The easy form]

The first thing you'll have to do is to decide where and how you want logs to be stored. In terms of the library you have to construct logging sinks and register them into the logging core. This should be done only once somewhere in the startup code of your application. The library provides support for several different logging sinks, such as STL streams and syslog where available, and a simplified interface to register them like that:

    logging::init_log_to_file("sample.log");

That would implicitly do all necessary actions to enable logging to a file named "sample.log". There are a number of other functions that initialize the library for, e.g. logging to console or syslog or even read the configuration from file. These functions can be combined if needed, for example:

    logging::init_log_to_file("sample.log");
    logging::init_log_to_console();

This call sequence will enable both logging to a text file and to console, effectively registering two sinks to the logging core.

[endsect]

[section The advanced form]

If you need a more comprehensive control over sinks configuration, you may consider registering them manually. The `init_log_to_file` function call in the section above can be expanded to this:

    // Construct the sink
    typedef sinks::synchronous_sink< sinks::text_ostream_backend > text_sink;
    boost::shared_ptr< text_sink > pSink = boost::make_shared< text_sink >();

    // Add a stream to write log to
    pSink->locked_backend()->add_stream(
        boost::make_shared< std::ofstream >("sample.log"));

    // Register the sink in the logging core
    logging::logging_core::get()->add_sink(pSink);

Ok, the first thing you may have noticed about sinks is that they are composed of two classes: the frontend and the backend. The frontend (which is the `synchronous_sink` class template in the snippet above) is responsible for various common tasks for all sinks, such as thread synchronization model and filtering. The backend (the `text_ostream_backend` class above) implements everything specific to the sink nature, text formatting and writing to a file being in this case. Every log record first gets to the frontend, which decides if it is going to be stored and, if it is, passes the record to the backend. There are a number of both frontends and backends provided by the library out of box that may be used with each other. This approach significantly reduces backends complexity (which is one of the most probable areas of the library extension) and improves code reusability.

The `synchronous_sink` class template above indicates that the sink is synchronous, that is, it allows several threads to log simultaneously and will block in case of contention. This means that the backend `text_ostream_backend` need not to worry about multithreading at all. There are two other sink frontends available out of box: `unlocked_sink` and `asynchronous_sink`. The `unlocked_sink` makes no synchronization at all and `asynchronous_sink` performs writing in a separate thread. The simplified functions like `init_log_to_file` and `init_log_to_console` always register a synchronous sink.

The `text_ostream_backend` class implements storing text records into STL-compatible streams. We have used a file stream above but we could have used any type of stream. For example, adding output to console could look as follows:

    // We have to provide an empty deleter to avoid destroying the global stream
    boost::shared_ptr< std::ostream > pStream(&std::clog, boost::empty_deleter());
    pSink->locked_backend()->add_stream(pStream);

The `text_ostream_backend` supports adding several streams. In that case its output will be duplicated to all added streams. This may be useful to duplicate output to console and file, since all the filtering, formatting and other overhead the library makes are done only once per record for the sink.

[note Please note the difference between registering several sinks with functions `init_log_to_*` and registering one sink with several target streams. While the former allows to independedly customize output to each stream, the latter would work considerably faster if such customization is not needed.]

The last thing worth noting here is that `locked_backend` member function call to access the sink backend. It is used to get a thread-safe access to the backend and is provided by all sink frontends. This function returns a smart-pointer to the backend and as long as it exists the backend is locked (which means even if another thread tries to log and the log record is passed to the sink, it will not be logged until you release the backend). The only exception is the `unlocked_sink` frontend which does not synchronize at all and simply returns an unlocked pointer to the backend.

[endsect]

[endsect]

[section:tutorial_2 Step 2: Creating loggers and writing logs]

[section Creating loggers: Object oriented programming style]

Now that we defined where the log is to be stored it's time to go on and try logging. In order to do this one has to create a logging source. This would be a logger object in our case and it is as simple as that:

    src::logger lg;

Note that unlike sinks sources need not to be registered anywhere since they interact directly with logging core. Also note that there are two versions of loggers provided by the library: the thread-safe ones and not thread-safe. For the not thread-safe loggers it is safe for different threads to write logs through different instances of loggers and thus there should be a separate logger for each thread that writes logs. The thread-safe counterparts may be accessed from different threads concurrently, but this would involve locking and may slow things down in case of intense logging. The thread-safe logger types have the `_mt` suffix in their name.

Regardless of the threas safety, all loggers provided by the library are default and copy-constructible and support swapping, so there should be no problem in making a logger a member of your class. As you will see later, such approach can give you additional benefits.

[endsect]

[section Creating loggers: Function oriented programming style]

In case if you cannot put a logger into your class (suppose you don't have one), the library provides a way of declaring global loggers like this:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

Here `my_logger` is a user-defined tag name that will be used later to retrieve the logger instance and `logger_mt` is the logger type. Any logger type provided by the library or defined by user can be used in such declaration. However, since the logger will have a single instance, you will normally want to use thread-safe loggers in a multithreaded application as global ones.

In case if you want to pass some arguments to the logger on construction, you can use the following macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS(my_logger, src::logger_mt, (arg1)(arg2)(arg3))

or even write the initialization code yourself:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::logger_mt)
    {
        // do something on logger initialization and return logger instance
        return src::logger_mt();
    }

You may have such declaration in either a header or a compiled cpp unit. You may even have it in different modules of your application, however, the declaration should be exactly the same in all places, including the definition of the logger type (`logger_mt` in this case) and all symbol bindings within the logger initialization body.

Later on you can acquire the logger like this:

    src::logger_mt& lg = get_my_logger();

or like this:

    src::logger_mt& lg = my_logger::get();

In any case, the `lg` will reference to the one and only instance of the logger throughout the application, even if the application consists of multiple modules.

[endsect]

[section Writing logs]

No matter what kind of logger you use (class member or global, thread-safe or not), to write a log record into a logger you could write something like this:

    if (lg.open_record())
        lg.strm() << "Hello world!";

Here the `open_record` function call determines if the record to be constructed is going to be consumed by at least one sink. Filtering is applied at this stage. Then the `strm` function returns an object with a defined `operator <<` that can be used to form the logging record message. You may output to log everything that has a well-defined output operator to an STL stream.

Of course, the above syntax can easily be wrapped into a macro and, in fact, users are encouraged to write their own macros instead of direct C++ logger interface usage. The log record above can be written like this:

    BOOST_LOG(lg) << "Hello, World!";

Looks a bit nicer, doesn't it? The `BOOST_LOG` macro, along with other similar ones, is defined by the library. Having all that code written, compiled and executed you should be able to see the "Hello, World!" record in the "sample.log" file and/or on your console if you added the `clog` stream in the [link log.tutorial.tutorial_1 Step 1] of this tutorial.

[endsect]

[endsect]

[section:tutorial_3 Step 3: Getting deeper. Attributes.]

Hey, all the fuss is just to have a string in the file, you say? That's right, you don't need a logging library to have something written into a file. But the library is capable of doing more: formatting and filtering are yet to come and these features are tightly coupled with the concept of attributes.

Each log record may have a number of attributes attached. Attributes may contain any essental information about conditions in which the log record occurred, such as position in code, executable module name, current date and time, or any piece of data relevant to your particular application and execution environment. An attribute may behave as a value generator, in which case it would return a different value for each log record it's involved in. As soon as the attribute generates the value, the latter becomes independent from the creator and may be used by different filters, formatters and sinks. But in order to do so one has to know the type of the value, or at least what types it may have. There are a number of commonly used attributes implemented in the library, you may find types of their values in the documentation.

Aside from that, there are three possible scopes of attributes: source-specific, thread-specific and global. The source-specific attributes are registered in sources (loggers, for instance) and are attached only to log records that are written through these particular sources. The thread-specific and global attributes should be registered directly in the logging core and, as follows from the naming, are attached to records made in a particular thread or to every record ever made, respectively. When a log record is made attribute values from these three sets are accumulated into a single view and passed to sinks, so there is no difference for them where the attribute was registered. Any attribute may be registered in any scope. Upon registering an attribute is given a unique name in order to make it possible to search for it. If it happens that the same named attribute is found in several scopes, the attribute from the most specific scope is taken into consideration in any further processing, including filtering and formatting. Such behavior makes it possible to override global or thread-scoped attributes with the ones registered in your local logger, thus reducing thread interference.

Getting back to our tutorial, let's add some attributes to our application.

[section The easy form]

There are attributes that are most likely to be used in almost any application. These are log record counter and a timestamp. They can be added with a single function call:

    logging::add_common_attributes();

With this call attributes "LineID" and "TimeStamp" are registered globally. The "LineID" attribute is a counter that increments for each record being made, the first record gets identifier 1. The value type of the attribute is `unsigned int`. The "TimeStamp" attribute always yelds the current time (i.e. the time when the log record is created, not the time it was written to a sink) and its value type is `boost::posix_time::ptime` (see [@http://www.boost.org/doc/libs/release/doc/html/date_time.html Boost.DateTime] documentation).

Some attrubutes are registered automatically on loggers construction. For example, `severity_logger` registers a source-specific attribute "Severity" which can be used to add a level of emphasis for different log records. For example:

    // We define our own severity levels
    enum severity_level
    {
        normal,
        notification,
        warning,
        error,
        critical
    };

    // The logger implicitly adds a source-specific attribute 'Severity' of type 'int' on construction
    src::severity_logger slg;

    BOOST_LOG_SEV(slg, normal) << "A regular message";
    BOOST_LOG_SEV(slg, warning) << "Something bad is going on but I can handle it";
    BOOST_LOG_SEV(slg, critical) << "Everything crumbles, shoot me now!";

The `BOOST_LOG_SEV` macro acts pretty much like `BOOST_LOG` except that it takes an additional argument for the `open_record` method of the logger. The expanded `BOOST_LOG_SEV` macro would look something like this:

    if (lg.open_record(src::keywords::severity = normal))
        lg.strm() << "A regular message";

You can see here that the `open_record` can take named arguments. Some logger types provided by the library have support for such additional parameters and this approach can certainly be used by users when writing their own loggers.

[endsect]

[section The advanced form]

Let's see what's under the hood of that `add_common_attributes` function we used in the easy form section. It might look something like this:

    boost::shared_ptr< logging::logging_core > pCore = logging::logging_core::get();
    pCore->add_global_attribute(
        "LineID", boost::make_shared< attrs::counter< unsigned int > >(1));
    pCore->add_global_attribute(
        "TimeStamp", boost::make_shared< attrs::local_clock >());

Here the `counter` and `local_clock` components are attribute classes, they derive from the common attribute interface `attribute`. The library provides a number of other attribute classes, including the `functor` attribute that calls some functional object on value acquision. For example, we can in a similar way register a `named_scope` attrubute:

    pCore->add_global_attribute(
        "Scope", boost::make_shared< attrs::named_scope >());

This will give the ability to store scope names in log for every log record the application makes. See the [link log.advanced.attributes Attributes] section for detailed description of attributes provided by the library.

[endsect]

[endsect]

[section:tutorial_4 Step 4: Formatting]

If you run the resulting code from the previous tutorial step you will see no difference between the two log records. That's because all these attributes we so carefully registered are not involved in formatting the output. By default the library just puts your message to the log file without examining any attributes. This behavior can be changed.

You can add a custom formatter to a sink backend that supports it (`text_ostream_backend` we used above being the one). The formatter is actually a function object that supports the following signature:

    void (ostream_type& strm, attribute_values_view const& attrs, string_type const& msg);

The formatter will be invoked whenever a log record passes filtering and is to be stored in log. The formatted record should be composed by insertion into STL-compatible output stream `strm`. The `attrs` argument contains all attributes attached to the record, and `msg` represents message text acquired by the logger.

While it is perfectly fine if you just write your own formatter function, the library provides a two ways to automatically generate it.

[section Lambda-style formatters]

You can create a formatter with a lambda-style expression like this:

    // This makes the sink to write log records that look like this:
    // 1: <0> [main] A normal severity message
    // 2: <3> [main] An error severity message
    pSink->locked_backend()->set_formatter(fmt::ostrm
        << fmt::attr< unsigned int >("LineID")
        << ": <" << fmt::attr< int >("Severity")
        << "> [" << fmt::named_scope("Scope")
        << "] " << fmt::message());

Here the `ostrm` is a placeholder for the stream to format the record in (the `strm` argument in terms of the formatter signature above). Other insertion arguments, such as `attr`, `named_scope` and `message`, are manipulators that define what should be stored in the stream. The `message` manipulator is a bit special since unlike all other manipulators it writes a preformatted message text acquired from the logger, not an attribute.

Some manipulators may accept additional arguments that customize their behavior. Most of these arguments are named and may be passed in [@http://www.boost.org/doc/libs/release/libs/parameter/doc/html/index.html Boost.Parameter] style. For example, `attr` supports format specifier in a printf-style string and with `named_scope` manipulator you may decide the direction of iteration through the list of scopes and the depth of iteration:

    using namespace fmt::keywords; // All argument name keywords reside in this namespace
    pSink->locked_backend()->set_formatter(fmt::ostrm
        << fmt::attr< unsigned int >("LineID", format="%08x") // make the line numbers to be written in hex, 8 symbols long
        << ": <" << fmt::attr< int >("Severity")
        << "> [" << fmt::named_scope("Scope", scope_iteration=reverse, scope_depth=4) // make scope iteration top-to-bottom, no more than 4 scopes to be written
        << "] " << fmt::message());

For the reference of the supported arguments see the reference of the corresponding manipulator. More manipulators are described in the [link log.advanced.formatters Advanced] section.

[endsect]

[section Boost.Format-style formatters]

In case if you need to make the log record form customizable, you can define formatters with with a syntax similar to [@http://www.boost.org/doc/libs/release/libs/format/index.html Boost.Format]. The same formatter as described above can be written as follows:

    // This makes the sink to write log records that look like this:
    // 1: <0> [main] A normal severity message
    // 2: <3> [main] An error severity message
    pSink->locked_backend()->set_formatter(
        fmt::format("%1%: <%2%> [%3%] %4%")
            % fmt::attr< unsigned int >("LineID")
            % fmt::attr< int >("Severity")
            % fmt::named_scope("Scope")
            % fmt::message());

The `format` placeholder accepts the format string with positional specification of all arguments being formatted. Note that only positional format is currently supported. However, format of individual attributes can still be customized with the corresponding manipulator arguments:

    pSink->locked_backend()->set_formatter(
        fmt::format("%1%: <%2%> [%3%] %4%")
            % fmt::attr< unsigned int >("LineID", format="%08x")
            % fmt::attr< int >("Severity")
            % fmt::named_scope("Scope", scope_iteration=reverse, scope_depth=4)
            % fmt::message());

[endsect]

[endsect]

[section:tutorial_5 Step 5: Filtering]

And now we have come to filtering log records. Filtering takes place before any formatting is done and is performed for each log record attempted to be written. Therefore a careful choice of filters is very critical for the performance of logging and, of course, for the amount of information left in logs. The library offers two phases of filtering: global and sink-based. The global filtering takes place prior to the sink-based and is intended to provide a way to globally disable or enable logging or to drop all low-priority and unneeded records. The sink-based filtering is a more fine tuning. Sink-specific filters basically decide which particular records will be processed by the particular sink.

Both phases of filtering are implemented the same way. The filter is a function object that supports the following signature:

    bool (attribute_values_view const& values);

As you can see, filtering is only possible by analyzing attribute values of each record. It is not possible to analyze record message text since it is not constructed at the point of filtering. However, if needed, it is possible to perform /late/ filtering in the sink implementation after the formatting is completed, but because of obvious performance loss of such approach it is not supported by the library sinks out of box.

The filter function object should return `true` if the record have passed the filtering (IOW, it should be written to log) and `false` otherwise. Like with formatters, it is possible to write your own filter from scratch or make use of a lambda-like syntax to generate one.

    // Setting global filter
    logging::logging_core::get()->set_filter(
        flt::attr< int >("Severity") >= warning); // Write all records with "warning" severity or higher

    // Setting a sink-specific filter
    pSink->set_filter(
        flt::has_attr("Tag") && // The sink will only write records that have an attribute "Tag"...
        flt::attr< std::string >("Tag").begins_with("LOGME")); // ...whose value begins with word "LOGME"

The syntax is quite similar to formatters. The difference is that there is no need in a hook placeholder like `ostrm`. You may see a more detailed description of filters in the [link log.advanced.filters Advanced] section.

[endsect]

[endsect]


[section:advanced Advanced features]

This section contains a more detailed description of library components and features. Some of them are presented in the [link log.tutorial Tutorual] section, so it is recommended to read it first to get the basic understanding of the library.

[section:sources Logging sources]

[endsect]

[section:sink_frontends Sink Frontends]

[endsect]

[section:sink_backends Sink Backends]

[endsect]

[section:filters Filters]

[endsect]

[section:formatters Formatters]

[endsect]

[section:attributes Attributes]

[section:named_scope Named scopes]

The logging library supports mainaining scopes stack tracking during the application execution. This stack may either be written to log or be used for other needs (for example, to save the exact call sequence that led to and exception when throwing one). The attribute `named_scope` implements support for scope naming, one can register it the following way:

    logging::logging_core::get()->add_global_attribute(
        "Scope", boost::make_shared< attrs::named_scope >());

Now we can mark execution scopes with macros `BOOST_LOG_FUNCTION` and `BOOST_LOG_NAMED_SCOPE` (the latter accepts a string literal as an argument) like this:

    void foo(int n)
    {
        // Mark the scope of the function foo
        BOOST_LOG_FUNCTION();

        switch (n)
        {
        case 0:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 0");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        case 1:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 1");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        default:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("default");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;
        }
    }

Later we will be able to see in log that the `bar` function was called from `foo` and, more precisely, from the case statement that corresponds the value of `n`. This may be very useful when tracking down subtle bugs that show only when `bar` is called from a specific location (e.g. if `bar` is being passed invalid arguments in that particular location).

Another good case is attaching the scope stack information to an exception. With help of Boost.Exception, this is possible:

    typedef boost::error_info< struct tag_scopes, attrs::named_scope > scopes_info;

    void bar(int x)
    {
        BOOST_LOG_FUNCTION();

        if (x < 0)
        {
            throw boost::enable_error_info(std::range_error("x must not be negative"))
                << scopes_info(attrs::named_scope::get_scopes());
        }
    }

    void foo()
    {
        BOOST_LOG_FUNCTION();

        try
        {
            bar(-1);
        }
        catch (std::range_error& e)
        {
            BOOST_LOG(lg) << "bar call failed: " << e.what() << ", scopes stack:\n"
                << *boost::get_error_info< scopes_info >(e);
        }
    }

[endsect]

[endsect]

[endsect]


[section:extension Extending the library]

[section:sinks Writing your own sinks]

[endsect]

[section:sources Writing your own sources]

[endsect]

[section:attributes Writing your own attributes]

[endsect]

[endsect]

[xinclude autodoc.xml]

[section:acknowledgements Acknowledgements]

* Luca Rigini wrote the initial implementation of the NT event log sink and made a lot of suggestions on how to improve the library in regard of writing user-defined sinks.
* Jean-Daniel Michaud, Michael Lacher and all others who took part in the discussion of the requirements to the library (http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Boost.Logging).
* John Torjo and Gennadiy Rozental for their discussion on the John's logging library on the Boost developers list. It helped a lot to learn the requirements and possible solutions for the library.
* All authors of the great Boost libraries that were involved in this library (notably, Boost.SmartPtr, Boost.Thread, Boost.Function, Boost.Optional, Boost.DateTime, Boost.Filesystem, Boost.Intrusive, Boost.IOStreams and other).

[endsect]
