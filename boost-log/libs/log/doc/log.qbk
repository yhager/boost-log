[library Boost.Log
    [quickbook 1.3]
    [authors [Semashev, Andrey]]
    [copyright 2007 Andrey Semashev]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt]).
    ]
    [id log]
    [source-mode c++]
    [last-revision $Date: 2008-06-17 16:53:50 $]
]

[c++]

[section Disclaimer]

This library is not an official part of [@http://www.boost.org Boost libraries collection] although it is aimed to be proposed for inclusion at some point.

[endsect]

[section:moti Motivation]

Today applications grow rapidly, becoming complicated and difficult to test and debug. Most of the time applications run on a remote site, leaving the developer little chance to monitor its execution and figure out the reason of its failure, once it should happen. Moreover, even the local debugging may become problematic if the application behavior depends heavilly on asynchronous third-party events, like device feedback or another process activity.

This is where logging may help. The application stores all essential information of its run time to log, and once something goes wrong this information can be used to analyse program behavior and make necessary corrections. There are other very useful applications of logging, such as gathering statistic information and alarming (i.e. indicating that the application is experiencing some problems). These tasks have proven to be vital for many real-world industrial applications.

This library aims to make logging significantly easier for the application developer. It provides a wide range of out-of-box tools, along with public interfaces ready to be used to extend the library. The main goals of the library are:

* Simplicity. A small example code snippet should be enough to get the feel of the library and be ready to use its basic features.
* Extensibility. A user should be able to extend library's functionality in ways of collecting and storing information into logs.
* Performance. The library should make as least performance impact on the user's application as possible.

[endsect]

[section:defs Definitions]

Here are definitions of some terms that will be used widely throughout the documentation:

* Log record. A single pack of information, collected from the user's application, that is candidate to be put in log. In a simple case the log record will be represented as a line of text in the log file after being processed by the logging library.
* Log attribute. An "attribute" is basically a piece of information of which the logging record consists. Attributes may have different types (integers, strings and more complex, including user defined types). Some examples of attributes: current time stamp, file name, line number, current scope name, etc..
* Log sink. A target, to which all log records are fed after being collected from user's application. It is sink's nature that defines where and how the log is going to be stored.
* Log source. An entry point for user's application to put log records to. In a simple case it is an object (logger) which maintains a set of attributes that will form a log record upon user's request. Hovewer, one can surely create a source that would emit log records on some third-party events (for example, by intercepting another application's console output).
* Log filter. A predicate that takes a log record and tells weither this record should be passed through or discarded.
* Log formatter. A functor that forms up the final shape of the output. Some sinks, like binary logging sink, may not need it although almost any text-based sink would use a formatter to compose its output.
* Logging core. The global entity that maintains connection between sources and sinks and applies filters to records. It is mainly used on the logging library initialization stage.
* i18n. Internationalization. The ability to manipulate wide characters.

[endsect]

[section:how_to_read How to read the documentation]

The documentation is oriented to both newbies and experienced library users. However, users are expected to be familiar with the commonly used Boost components, such as `shared_ptr`, `make_shared` (see [@http://www.boost.org/doc/libs/release/libs/smart_ptr/smart_ptr.htm Boost.SmartPtr]), and `function` ([@http://www.boost.org/doc/libs/release/doc/html/function.html Boost.Function]). Some parts of the documentation will refer to other Boost libraries as needed.

If this is your first experience with the library, it is recommended to read the [link log.installation Instalation] and [link log.tutorial Tutorial] sections first. The tutorial gives the overview of the library features with sample code snippets. Some tutorial steps are presented in two forms: simple and advanced. The simple form typically describes the most common and easy way to do the task and it is being recommended to be read by newbies. The advanced form usually gives an expanded way to do the same thing but with ability to do some extra customization. It also often explains the library features behind the simple interface in a more detailed way. This form may come handy for more experienced users and should generally be read if your needs are not satisfied with the easy way.

Besides the tutorial there is an [link advanced Advanced features] chapter. This part gives description of other tools provided by the library that were not covered by the tutorial. This chapter is better to be read on per-case basis.

Last, but not least, there is a reference which gives the formal description of library components.

For simplicity in the code snippets in this documentation it shall be assumed that the following namespace aliases were defined:

    namespace logging = boost::log;
    namespace sinks = boost::log::sinks;
    namespace src = boost::log::sources;
    namespace fmt = boost::log::formatters;
    namespace flt = boost::log::filters;
    namespace attrs = boost::log::attributes;

[endsect]

[section:installation Installation]

The library has the compiled part which should be built as described in the [@http://www.boost.org/doc/libs/release/more/getting_started/ Getting Started] article. One thing should be noted, though. If your aplication consists of more than one module (e.g. an exe and one or several dll's) the library _must_ be built as a shared object. If you have a single executable, you may build the library as a static library.

The library supports a number of configuration macros:

[table Configuration macros
    [[Macro name]                               [Effect]]
    [[`BOOST_LOG_DYN_LINK`]                     [If defined in user code, the library will assume the binary is built as a dynamically loaded library (dll or so). Otherwise it is assumed that the library is built in static mode. This macro must be either defined or not defined for all translation units of user application that use logging. This macro can help with auto-linking on platforms that support it.]]
    [[`BOOST_ALL_DYN_LINK`]                     [Same as `BOOST_LOG_DYN_LINK` but also affects other Boost libraries the same way]]
    [[`BOOST_LOG_USE_CHAR`]                     [If defined, enables support for narrow character logging. Has effect on both the library compilation and user code compilation.]]
    [[`BOOST_LOG_USE_WCHAR_T`]                  [If defined, enables support for wide character logging. Has effect on both the library compilation and user code compilation. If neither `BOOST_LOG_USE_CHAR` nor `BOOST_LOG_USE_WCHAR_T` is defined, it is assumed the both character types support is enabled. Defining only one of them allows to significantly reduce binary size of the library.]]
    [[`BOOST_LOG_NO_QUERY_PERFORMANCE_COUNTER`] [Has effect on Windows platform only, on both the library compilation and user code compilation stages. If defined, disables support for `QueryPerformanceCounter` API in the `timer` attribute. This will result in a significantly less accurate time readings and may reduce performance a little. The macro is intended to solve possible problems with earlier revisions of AMD Athlon CPU, described [@http://support.microsoft.com/?scid=kb;en-us;895980 here] and [@http://support.microsoft.com/?id=896256 here].]]
    [[`BOOST_LOG_USE_NATIVE_SYSLOG`]            [Has effect on the library compilation stage. If for some reason the support for native SysLog API is not detected, define this macro to enable support for SysLog.]]
]

You may define configuration macros in the `bjam` command line, like this:

[pre
    bjam --with-log variant=release define=BOOST_LOG_USE_CHAR stage
]

The logging library also uses several Boost libraries that need building too. These are [@http://www.boost.org/doc/libs/release/libs/filesystem/doc/index.htm Boost.Filesystem], [@http://www.boost.org/doc/libs/release/libs/system/doc/index.html Boost.System], [@http://www.boost.org/doc/libs/release/doc/html/date_time.html Boost.DateTime], [@http://www.boost.org/doc/libs/release/doc/html/thread.html Boost.Thread] and [@http://www.boost.org/doc/libs/release/libs/regex/index.html Boost.Regex]. Refer to their documentation for detailed instructions on building procedure.

[endsect]

[section:tutorial Tutorial]

In this section we shall walk through the essential steps to get started with the library. After reading this part you should be able to initialize the library and add logging to your application. The code of this tutorial is also available in a single example resided in the `libs/log/examples/basic_usage` directory. You may feel free to play around with it, compile and see the result.

[section:tutorial_1 Step 1: Picking sinks]

[section The simple form]

The first thing you'll have to do is to decide where and how you want logs to be stored. In terms of the library you have to construct logging sinks and register them into the logging core. This should be done only once somewhere in the startup code of your application. The library provides support for several different logging sinks, such as STL streams and syslog where available, and a simplified interface to register them like that:

    logging::init_log_to_file("sample.log");

That would implicitly do all necessary actions to enable logging to a file named "sample.log". There are a number of other functions that initialize the library for, e.g. logging to console or syslog or even read the configuration from file. These functions can be combined if needed, for example:

    logging::init_log_to_file("sample.log");
    logging::init_log_to_console();

This call sequence will enable both logging to a text file and to console, effectively registering two sinks to the logging core.

[endsect]

[section The advanced form]

If you need a more comprehensive control over sinks configuration, you may consider registering them manually. The `init_log_to_file` function call in the section above can be expanded to this:

    // Construct the sink
    typedef sinks::synchronous_sink< sinks::text_ostream_backend > text_sink;
    boost::shared_ptr< text_sink > pSink = boost::make_shared< text_sink >();

    // Add a stream to write log to
    pSink->locked_backend()->add_stream(
        boost::make_shared< std::ofstream >("sample.log"));

    // Register the sink in the logging core
    logging::logging_core::get()->add_sink(pSink);

Ok, the first thing you may have noticed about sinks is that they are composed of two classes: the frontend and the backend. The frontend (which is the `synchronous_sink` class template in the snippet above) is responsible for various common tasks for all sinks, such as thread synchronization model and filtering. The backend (the `text_ostream_backend` class above) implements everything specific to the sink nature, text formatting and writing to a file being in this case. Every log record first gets to the frontend, which decides if it is going to be stored and, if it is, passes the record to the backend. There are a number of both frontends and backends provided by the library out of box that may be used with each other. This approach significantly reduces backends complexity (which is one of the most probable areas of the library extension) and improves code reusability.

The `synchronous_sink` class template above indicates that the sink is synchronous, that is, it allows several threads to log simultaneously and will block in case of contention. This means that the backend `text_ostream_backend` need not to worry about multithreading at all. There are two other sink frontends available out of box: `unlocked_sink` and `asynchronous_sink`. The `unlocked_sink` makes no synchronization at all and `asynchronous_sink` performs writing in a separate thread. The simplified functions like `init_log_to_file` and `init_log_to_console` always register a synchronous sink.

The `text_ostream_backend` class implements storing text records into STL-compatible streams. We have used a file stream above but we could have used any type of stream. For example, adding output to console could look as follows:

    // We have to provide an empty deleter to avoid destroying the global stream
    boost::shared_ptr< std::ostream > pStream(&std::clog, boost::empty_deleter());
    pSink->locked_backend()->add_stream(pStream);

The `text_ostream_backend` supports adding several streams. In that case its output will be duplicated to all added streams. This may be useful to duplicate output to console and file, since all the filtering, formatting and other overhead the library makes are done only once per record for the sink.

[note Please note the difference between registering several sinks with functions `init_log_to_*` and registering one sink with several target streams. While the former allows to independedly customize output to each stream, the latter would work considerably faster if such customization is not needed.]

The last thing worth noting here is that `locked_backend` member function call to access the sink backend. It is used to get a thread-safe access to the backend and is provided by all sink frontends. This function returns a smart-pointer to the backend and as long as it exists the backend is locked (which means even if another thread tries to log and the log record is passed to the sink, it will not be logged until you release the backend). The only exception is the `unlocked_sink` frontend which does not synchronize at all and simply returns an unlocked pointer to the backend.

[endsect]

[endsect]

[section:tutorial_2 Step 2: Creating loggers and writing logs]

[section Creating loggers: Object oriented programming style]

Now that we defined where the log is to be stored it's time to go on and try logging. In order to do this one has to create a logging source. This would be a logger object in our case and it is as simple as that:

    src::logger lg;

Note that unlike sinks sources need not to be registered anywhere since they interact directly with logging core. Also note that there are two versions of loggers provided by the library: the thread-safe ones and not thread-safe. For the not thread-safe loggers it is safe for different threads to write logs through different instances of loggers and thus there should be a separate logger for each thread that writes logs. The thread-safe counterparts may be accessed from different threads concurrently, but this would involve locking and may slow things down in case of intense logging. The thread-safe logger types have the `_mt` suffix in their name.

Regardless of the threas safety, all loggers provided by the library are default and copy-constructible and support swapping, so there should be no problem in making a logger a member of your class. As you will see later, such approach can give you additional benefits.

[endsect]

[section Creating loggers: Function oriented programming style]

In case if you cannot put a logger into your class (suppose you don't have one), the library provides a way of declaring global loggers like this:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::logger_mt)

Here `my_logger` is a user-defined tag name that will be used later to retrieve the logger instance and `logger_mt` is the logger type. Any logger type provided by the library or defined by user can be used in such declaration. However, since the logger will have a single instance, you will normally want to use thread-safe loggers in a multithreaded application as global ones.

In case if you want to pass some arguments to the logger on construction, you can use the following macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS(my_logger, src::logger_mt, (arg1)(arg2)(arg3))

or even write the initialization code yourself:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::logger_mt)
    {
        // do something on logger initialization and return logger instance
        return src::logger_mt();
    }

You may have such declaration in either a header or a compiled cpp unit. You may even have it in different modules of your application, however, the declaration should be exactly the same in all places, including the definition of the logger type (`logger_mt` in this case) and all symbol bindings within the logger initialization body.

Later on you can acquire the logger like this:

    src::logger_mt& lg = get_my_logger();

or like this:

    src::logger_mt& lg = my_logger::get();

In any case, the `lg` will reference to the one and only instance of the logger throughout the application, even if the application consists of multiple modules.

[endsect]

[section Writing logs]

No matter what kind of logger you use (class member or global, thread-safe or not), to write a log record into a logger you could write something like this:

    if (lg.open_record())
        lg.strm() << "Hello world!";

Here the `open_record` function call determines if the record to be constructed is going to be consumed by at least one sink. Filtering is applied at this stage. Then the `strm` function returns an object with a defined `operator <<` that can be used to form the logging record message. You may output to log everything that has a well-defined output operator to an STL stream.

Of course, the above syntax can easily be wrapped into a macro and, in fact, users are encouraged to write their own macros instead of direct C++ logger interface usage. The log record above can be written like this:

    BOOST_LOG(lg) << "Hello, World!";

Looks a bit nicer, doesn't it? The `BOOST_LOG` macro, along with other similar ones, is defined by the library. Having all that code written, compiled and executed you should be able to see the "Hello, World!" record in the "sample.log" file and/or on your console if you added the `clog` stream in the [link log.tutorial.tutorial_1 Step 1] of this tutorial.

[endsect]

[endsect]

[section:tutorial_3 Step 3: Getting deeper. Attributes.]

Hey, all the fuss is just to have a string in the file, you say? That's right, you don't need a logging library to have something written into a file. But the library is capable of doing more: formatting and filtering are yet to come and these features are tightly coupled with the concept of attributes.

Each log record may have a number of attributes attached. Attributes may contain any essental information about conditions in which the log record occurred, such as position in code, executable module name, current date and time, or any piece of data relevant to your particular application and execution environment. An attribute may behave as a value generator, in which case it would return a different value for each log record it's involved in. As soon as the attribute generates the value, the latter becomes independent from the creator and may be used by different filters, formatters and sinks. But in order to do so one has to know the type of the value, or at least what types it may have. There are a number of commonly used attributes implemented in the library, you may find types of their values in the documentation.

Aside from that, there are three possible scopes of attributes: source-specific, thread-specific and global. The source-specific attributes are registered in sources (loggers, for instance) and are attached only to log records that are written through these particular sources. The thread-specific and global attributes should be registered directly in the logging core and, as follows from the naming, are attached to records made in a particular thread or to every record ever made, respectively. When a log record is made attribute values from these three sets are accumulated into a single view and passed to sinks, so there is no difference for them where the attribute was registered. Any attribute may be registered in any scope. Upon registering an attribute is given a unique name in order to make it possible to search for it. If it happens that the same named attribute is found in several scopes, the attribute from the most specific scope is taken into consideration in any further processing, including filtering and formatting. Such behavior makes it possible to override global or thread-scoped attributes with the ones registered in your local logger, thus reducing thread interference.

Getting back to our tutorial, let's add some attributes to our application.

[section The simple form]

There are attributes that are most likely to be used in almost any application. These are log record counter and a timestamp. They can be added with a single function call:

    logging::add_common_attributes();

With this call attributes "LineID" and "TimeStamp" are registered globally. The "LineID" attribute is a counter that increments for each record being made, the first record gets identifier 1. The value type of the attribute is `unsigned int`. The "TimeStamp" attribute always yelds the current time (i.e. the time when the log record is created, not the time it was written to a sink) and its value type is `boost::posix_time::ptime` (see [@http://www.boost.org/doc/libs/release/doc/html/date_time.html Boost.DateTime] documentation).

Some attrubutes are registered automatically on loggers construction. For example, `severity_logger` registers a source-specific attribute "Severity" which can be used to add a level of emphasis for different log records. For example:

    // We define our own severity levels
    enum severity_level
    {
        normal,
        notification,
        warning,
        error,
        critical
    };

    // The logger implicitly adds a source-specific attribute 'Severity' of type 'int' on construction
    src::severity_logger slg;

    BOOST_LOG_SEV(slg, normal) << "A regular message";
    BOOST_LOG_SEV(slg, warning) << "Something bad is going on but I can handle it";
    BOOST_LOG_SEV(slg, critical) << "Everything crumbles, shoot me now!";

The `BOOST_LOG_SEV` macro acts pretty much like `BOOST_LOG` except that it takes an additional argument for the `open_record` method of the logger. The expanded `BOOST_LOG_SEV` macro would look something like this:

    if (lg.open_record(src::keywords::severity = normal))
        lg.strm() << "A regular message";

You can see here that the `open_record` can take named arguments. Some logger types provided by the library have support for such additional parameters and this approach can certainly be used by users when writing their own loggers.

[endsect]

[section The advanced form]

Let's see what's under the hood of that `add_common_attributes` function we used in the simple form section. It might look something like this:

    boost::shared_ptr< logging::logging_core > pCore = logging::logging_core::get();
    pCore->add_global_attribute(
        "LineID", boost::make_shared< attrs::counter< unsigned int > >(1));
    pCore->add_global_attribute(
        "TimeStamp", boost::make_shared< attrs::local_clock >());

Here the `counter` and `local_clock` components are attribute classes, they derive from the common attribute interface `attribute`. The library provides a number of other attribute classes, including the `functor` attribute that calls some functional object on value acquision. For example, we can in a similar way register a `named_scope` attrubute:

    pCore->add_global_attribute(
        "Scope", boost::make_shared< attrs::named_scope >());

This will give the ability to store scope names in log for every log record the application makes. See the [link log.advanced.attributes Attributes] section for detailed description of attributes provided by the library.

[endsect]

[endsect]

[section:tutorial_4 Step 4: Formatting]

If you run the resulting code from the previous tutorial step you will see no difference between the two log records. That's because all these attributes we so carefully registered are not involved in formatting the output. By default the library just puts your message to the log file without examining any attributes. This behavior can be changed.

You can add a custom formatter to a sink backend that supports it (`text_ostream_backend` we used above being the one). The formatter is actually a function object that supports the following signature:

    void (ostream_type& strm, attribute_values_view const& attrs, string_type const& msg);

The formatter will be invoked whenever a log record passes filtering and is to be stored in log. The formatted record should be composed by insertion into STL-compatible output stream `strm`. The `attrs` argument contains all attributes attached to the record, and `msg` represents message text acquired by the logger.

While it is perfectly fine if you just write your own formatter function, the library provides a two ways to automatically generate it.

[section Lambda-style formatters]

You can create a formatter with a lambda-style expression like this:

    // This makes the sink to write log records that look like this:
    // 1: <0> [main] A normal severity message
    // 2: <3> [main] An error severity message
    pSink->locked_backend()->set_formatter(fmt::ostrm
        << fmt::attr< unsigned int >("LineID")
        << ": <" << fmt::attr< int >("Severity")
        << "> [" << fmt::named_scope("Scope")
        << "] " << fmt::message());

Here the `ostrm` is a placeholder for the stream to format the record in (the `strm` argument in terms of the formatter signature above). Other insertion arguments, such as `attr`, `named_scope` and `message`, are manipulators that define what should be stored in the stream. The `message` manipulator is a bit special since unlike all other manipulators it writes a preformatted message text acquired from the logger, not an attribute.

Some manipulators may accept additional arguments that customize their behavior. Most of these arguments are named and may be passed in [@http://www.boost.org/doc/libs/release/libs/parameter/doc/html/index.html Boost.Parameter] style. For example, `attr` supports format specifier in a printf-style string and with `named_scope` manipulator you may decide the direction of iteration through the list of scopes and the depth of iteration:

    using namespace fmt::keywords; // All argument name keywords reside in this namespace
    pSink->locked_backend()->set_formatter(fmt::ostrm
        << fmt::attr< unsigned int >("LineID", format = "%08x") // make the line numbers to be written in hex, 8 symbols long
        << ": <" << fmt::attr< int >("Severity")
        << "> [" << fmt::named_scope("Scope", scope_iteration = reverse, scope_depth = 4) // make scope iteration top-to-bottom, no more than 4 scopes to be written
        << "] " << fmt::message());

For the reference of the supported arguments see the reference of the corresponding manipulator. More manipulators are described in the [link log.advanced.formatters Advanced] section.

[endsect]

[section Boost.Format-style formatters]

In case if you need to make the log record form customizable, you can define formatters with with a syntax similar to [@http://www.boost.org/doc/libs/release/libs/format/index.html Boost.Format]. The same formatter as described above can be written as follows:

    // This makes the sink to write log records that look like this:
    // 1: <0> [main] A normal severity message
    // 2: <3> [main] An error severity message
    pSink->locked_backend()->set_formatter(
        fmt::format("%1%: <%2%> [%3%] %4%")
            % fmt::attr< unsigned int >("LineID")
            % fmt::attr< int >("Severity")
            % fmt::named_scope("Scope")
            % fmt::message());

The `format` placeholder accepts the format string with positional specification of all arguments being formatted. Note that only positional format is currently supported. However, format of individual attributes can still be customized with the corresponding manipulator arguments:

    pSink->locked_backend()->set_formatter(
        fmt::format("%1%: <%2%> [%3%] %4%")
            % fmt::attr< unsigned int >("LineID", format = "%08x")
            % fmt::attr< int >("Severity")
            % fmt::named_scope("Scope", scope_iteration = reverse, scope_depth = 4)
            % fmt::message());

[endsect]

[endsect]

[section:tutorial_5 Step 5: Filtering]

And now we have come to filtering log records. Filtering takes place before any formatting is done and is performed for each log record attempted to be written. Therefore a careful choice of filters is very critical for the performance of logging and, of course, for the amount of information left in logs. The library offers two phases of filtering: global and sink-based. The global filtering takes place prior to the sink-based and is intended to provide a way to globally disable or enable logging or to drop all low-priority and unneeded records. The sink-based filtering is a more fine tuning. Sink-specific filters basically decide which particular records will be processed by the particular sink.

Both phases of filtering are implemented the same way. The filter is a function object that supports the following signature:

    bool (attribute_values_view const& values);

As you can see, filtering is only possible by analyzing attribute values of each record. It is not possible to analyze record message text since it is not constructed at the point of filtering. However, if needed, it is possible to perform /late/ filtering in the sink implementation after the formatting is completed, but because of obvious performance loss of such approach it is not supported by the library sinks out of box.

The filter function object should return `true` if the record have passed the filtering (IOW, it should be written to log) and `false` otherwise. Like with formatters, it is possible to write your own filter from scratch or make use of a lambda-like syntax to generate one.

    // Setting global filter
    logging::logging_core::get()->set_filter(
        flt::attr< int >("Severity") >= warning); // Write all records with "warning" severity or higher

    // Setting a sink-specific filter
    pSink->set_filter(
        flt::has_attr("Tag") && // The sink will only write records that have an attribute "Tag"...
        flt::attr< std::string >("Tag").begins_with("LOGME")); // ...whose value begins with word "LOGME"

The syntax is quite similar to formatters. The difference is that there is no need in a hook placeholder like `ostrm`. You may see a more detailed description of filters in the [link log.advanced.filters Advanced] section.

[endsect]

[endsect]


[section:advanced Advanced features]

This section contains a more detailed description of library components and features. Some of them are presented in the [link log.tutorial Tutorual] section, so it is recommended to read it first to get the basic understanding of the library.

[section:sources Logging sources]

[section:basic_logger Basic loggers]

    #include <boost/log/sources/basic_logger.hpp>

The simpliest logging sources provided by the library are loggers `logger` and its thread-safe version, `logger_mt` (`wlogger` and `wlogger_mt` for wide-character logging, accordingly). These loggers only provide an ability to store source-specific attributes within themselves and, of course, to form log records. This type of loggers should probably be used in case if there is no need in advanced features like severity level checks. It may well be used as a tool to collect application statistics and register application events, such as notifications and alarms. In such cases the logger is normally used in conjunction with [link log.advanced.attributes.scoped_attributes scoped attributes] to attach the needed data to the notification event. Below is an example of usage:

    class network_connection
    {
        src::logger m_logger;
        src::logger::attribute_set_type::iterator m_remote_addr;

    public:
        void on_connected(std::string const& remote_addr)
        {
            // Put the remote address into the logger to automatically attach it to every log record written through the logger
            m_remote_addr = m_logger.add_attribute("RemoteAddress",
                boost::make_shared< attr::constant< std::string > >(remote_addr)).first;

            // The straightforward way of logging
            if (m_logger.open_record())                         // check the filters
                m_logger.strm() << "Connection established";    // format the record
        }
        void on_disconnected()
        {
            // The simplier way of logging: the above "if" condition is wrapped into a neat macro
            BOOST_LOG(m_logger) << "Connection shut down";

            // Remove the attribute with the remote address
            m_logger.remove_attribute(m_remote_addr);
        }
        void on_data_received(std::size_t size)
        {
            // Put the size as an additional attrubute so it can be collected and accumulated later if needed
            // The attribute will be attached to the only log record that is made within the current scope
            BOOST_LOG_SCOPED_LOGGER_TAG(m_logger, "ReceivedSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_logger) << "Some data received";
        }
        void on_data_sent(std::size_t size)
        {
            BOOST_LOG_SCOPED_LOGGER_TAG(m_logger, "SentSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_logger) << "Some data sent";
        }
    };

Class `network_connection` in the code snippet above represents an approach of implementing simple logging and statistic information gathering in a network-related application. Each of the presented methods of the class effectively marks a corresponding event that may be tracked and collected on sinks level. Furthermore, other methods of the class, that are not shown here for simplicity, are able to write logs too. Note that every log record ever made in the connected state of the `network_connection` object will be implicitly marked up with an address of the remote site.

[endsect]

[section:severity_level_logger Loggers with severity level support]

    #include <boost/log/sources/severity_logger.hpp>

An ability to distinguish some log records from others based on some kind of level of severity or importance is one of the most frequently requested feature. The classes `severity_logger` and `severity_logger_mt` (along with their `wseverity_logger` and `wseverity_logger_mt` wide-char counterparts) provide this functionality.

The loggers automatically register a special source-specific attribute "Severity" (attribute value type is `int`), which can be set for every record in a compact and efficient manner, with a named argument `severity` that can be passed to the constructor and/or the `open_record` method. If passed to the logger constructor, the `severity` argument sets the default value of the severity level that will be used if none provided in the `open_record` arguments. The `severity` argument passed to the `open_record` method sets the level of the particular log record being made.

The actual values of this attribute and their meaning is entirely user-defined. However, it is recommended to use level of value equivalent to zero as a base point for other values. This is because the default-constructed logger object sets default severity level to zero. It is also recommended to define the same levels of severity for the entire application in order to avoid the confusion in the written logs later. The following code snippet shows the usage of `severity_logger`.

    // User-defined severity levels
    enum my_levels
    {
        normal,
        warning,
        error
    };

    void foo()
    {
        // The default-constructed logger will use default level 0
        src::severity_logger lg;

        // The straightforward usage with default severity level (which is 0)
        if (lg.open_record())
            lg.strm() << "A default-severity log record";

        // The straightforward usage with a specific level value
        if (lg.open_record(src::keywords::severity = warning))
            lg.strm() << "A warning level log record";

        // The default severity can be specified in constructor
        src::severity_logger error_lg(src::keywords::severity = error);

        // There are predefined macros that make the usage easier
        BOOST_LOG_SEV(lg, warning) << "A warning level log record";

        // Thanks to the default severity level, you can use the basic macros too
        BOOST_LOG(error_lg) << "An error level log record";
    }

And, of course, severity loggers also provide the same functionality the [link log.advanced.sources.basic_logger basic loggers] do.

[endsect]

[section:channel_logger Loggers with channel support]

    #include <boost/log/sources/channel_logger.hpp>

Sometimes it is important to categorize log records based on some constant piece information, such as module or class name, relation of the logged information to some specific domain of application functionality (e.g. network or file system related messages) or some constant tag that may be used later to filter these records to a specific sink. This feature is fulfilled with loggers `channel_logger`, `channel_logger_mt` and their wide-char counterparts `wchannel_logger`, `wchannel_logger_mt`. These loggers automatically register a string attribute named "Channel". This attribute can be set only in the logger constructor with a named argument `channel` and cannot be changed during the logger lifetime. Aside from that the usage is similar to the [link log.advanced.sources.basic_logger basic loggers]:

    class network_connection
    {
        src::channel_logger m_net;
        src::channel_logger m_stat;
        src::logger::attribute_set_type::iterator m_remote_addr;

    public:
        network_connection() :
            // We can dump network-related messages through this logger and be able to filter them later
            m_net(src::keywords::channel = "net"),
            // We also can separate statistic records in a different channel in order to route them to a different sink
            m_stat(src::keywords::channel = "stat")
        {
        }

        void on_connected(std::string const& remote_addr)
        {
            // Put message to the "net" channel
            BOOST_LOG(m_net) << "Connection established";
        }
        void on_disconnected()
        {
            // Put message to the "net" channel
            BOOST_LOG(m_net) << "Connection shut down";
        }
        void on_data_received(std::size_t size)
        {
            // Put the size as an additional attrubute so it can be collected and accumulated later if needed
            // The attribute will be attached to the only log record that is made within the current scope
            BOOST_LOG_SCOPED_LOGGER_TAG(m_stat, "ReceivedSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_stat) << "Some data received";
        }
        void on_data_sent(std::size_t size)
        {
            BOOST_LOG_SCOPED_LOGGER_TAG(m_stat, "SentSize", attr::constant< std::size_t >, size);
            BOOST_LOG(m_stat) << "Some data sent";
        }
    };

[endsect]

[section:mixed_loggers Loggers with mixed features]

    #include <boost/log/sources/severity_channel_logger.hpp>

If you wonder whether you can use a mixed set of several logger features in one logger, then yes, you certainly can. The library provides `severity_channel_logger` and `severity_channel_logger_mt` (with their wide-char analogues `wseverity_channel_logger` and `wseverity_channel_logger_mt`) which combine features of the described loggers with [link log.advanced.sources.severity_level_logger severity level] and [link log.advanced.sources.channel_logger channels] support. You can also design your own logger features and combine them with the ones provided by the library, as described in the [link log.extension.sources Extending the library] section.

[endsect]

[section:global_storage Global storage for loggers]

    #include <boost/log/sources/global_logger_storage.hpp>

Sometimes it is inconvenient to have a logger object to be able to write logs. This issue is often present in a functional-style code with no obvious places where a logger could be stored. An other domain where the problem persists is generic libraries that want to support logging. In such cases it would be more convenient to have one or several global loggers in order to easily access them in every place when needed. In this regard `std::cout` is a good example of such a logger.

The library provides a way to declare global loggers that can be accessed pretty much like `std::cout`. In fact, this feature can be used with any loggers, including user-defined ones. Having declared a global logger, one can be sure to have a thread-safe access to this logger instance from any place of the application code. The library also guarantees that a global logger instance will be singular even across module boundaries. This allows to employ logging even in header-only components that may be compiled into different modules.

The easiest way to declare a global logger is to use the following macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER(my_logger, src::severity_logger_mt)

The `my_logger` argument gives the logger a name that may be used to acquire the logger instance. The second parameter denotes the logger type. In multithreaded applications, when the logger can be accessed from different threads, users will normally want to use thread-safe versions of loggers.

In case if there is a need to pass arguments to the logger constructor, there is another macro:

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS(
        my_logger,
        src::severity_channel_logger,
        (src::keywords::severity = error)(src::keywords::channel = "my_channel"))

The last macro argument is a [@http://www.boost.org/doc/libs/release/libs/preprocessor/doc/index.html Boost.Preprocessor] sequence of arguments passed to the logger constructor. Be careful, however, when using non-constant expressions and references to objects as constructor arguments, since the arguments are evaluated only once and it is often difficult to tell the exact moment when it is done. The logger is constructed on the first request from whichever part of the application that has the knowledge of the logger declaration. It is up to user to make sure that all arguments have valid states at that point.

The third macro of this section provides maximum flexibility, allowing user to actually define the logic of creating the logger.

    BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT(my_logger, src::severity_logger_mt)
    {
        // Do something that needs to be done on logger initialization, e.g. add a stop watch attribute
        src::severity_logger_mt lg;
        lg.add_attribute("StopWatch", boost::make_shared< attrs::timer >());
        // The initializing routine must return the logger instance
        return lg;
    }

Like the `BOOST_LOG_DECLARE_GLOBAL_LOGGER_CTOR_ARGS` macro, the initializing code is called only once, on the first request of the logger.

[important Beware of the One Definition Rule (ODR) violation issues. Regardless of the way of logger declaration you choose, you should ensure that [_the logger is declared in exactly the same way at all occurrences] and [_all symbol names involved in the declaration resolve to the same entities]. The latter includes the names used within the initialization routine of the `BOOST_LOG_DECLARE_GLOBAL_LOGGER_INIT` macro, such as references to external variables, functions and types. The library tries to protect itself from ODR violations to a certain degree, but in general the behavior is undefined if the rule is violated.]

In order to acquire the logger instance you may use either

    src::severity_logger_mt& lg = get_my_logger();

or

    src::severity_logger_mt& lg = my_logger::get();

which are equivalent. Further usage of the logger is completely the same as it was a regular logger object of the corresponding type.

[endsect]

[endsect]


[section:sink_frontends Sink Frontends]

Every sink object that is compatible with the logging library is required to support interface `sink< CharT >`, where `CharT` is the appropriate character type. This interface is used by `logging_core` to perform sink-specific filtering and pass log records to sinks. Technically speaking, one can derive his class from the `sink` template and have his new-found sink, but for sake of code reusing and sink implementation simplicity the library suggests separated concepts of sink frontend and sink backend. Sink frontends derive from the `sink` template and encapsulate the logic of filtering and thread synchronization. Most probably you won't have to write your own frontend once you need to create a new type of sink, because the library provides a number of frontends that cover most use cases. See [link log.advanced.sink_backends Sink Backends] section for more details on interface between frontends and backends.

[section:unlocked Unlocked sink frontend]

    #include <boost/log/sinks/sink.hpp>

The unlocked sink frontend is implemented with the `unlocked_sink` class template. This frontend provides the most basic service for the backend, which is filtering. The `unlocked_sink` performs no thread synchronization when accessing the backend, assuming that either the syncronization is not needed or the syncronization is implemented in the backend. However, filtering is still thread-safe (that is, one can safely change filter in the `unlocked_sink` frontend while other threads are writing logs through this sink). This is the only sink frontend available in a single thread environment. The example of use is as follows:

    // Some sink backend (for simplicity synchronization code omitted)
    class my_backend :
        public sinks::basic_sink_backend< char, sinks::backend_synchronization_tag >
    {
    public:
        // The method is called for every log record being put into the sink backend
        void write_message(values_view_type const& attributes, string_type const& message)
        {
            std::cout << message << std::endl;
        }
    };

    // The function registers my_backend sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // The simpliest way, the backend is default-constructed
        boost::shared_ptr< sink< char > > sink1(new sinks::unlocked_sink< my_backend >);
        core->add_sink(sink1);

        // One can construct backend separately and pass it to the frontend
        boost::shared_ptr< my_backend > backend(new my_backend);
        boost::shared_ptr< sink< char > > sink2(new sinks::unlocked_sink< my_backend >(backend));
        core->add_sink(sink2);

        // You can manage filtering through the sink interface
        sink1->set_filter(flt::attr< int >("Severity") >= warning);
        sink2->set_filter(flt::attr< std::string >("Channel") == "net");
    }

[endsect]

[section:sync Synchronous sink frontend]

    #include <boost/log/sinks/sink.hpp>

The synchronous sink frontend is implemented with the `synchronous_sink` class template. It is similar to the `unlocked_sink` but additionally provides thread synchronization with a mutex before passing log records to the backend. All sink backends that support formatting currently require thread synchronization in the frontend.

The synchronous sink also introduce an ability to acquire a pointer to the locked backend. As long as the pointer exists, the backend is guaranteed not to be accessed from other threads, unless the access is done through another frontend or a direct reference to the backend. This feature can be useful if there is a need to perform some updates on the sink backend while other threads may be writing logs. Beware, though, that while the backend is locked any other thread that tries to write a log record to the sink gets blocked until the backend is released.

The usage is similar to the `unlocked_sink`.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // Create a backend and initialize it with a stream
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));

        // Wrap it into the frontend and register in the core
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);

        // You can manage filtering through the sink interface
        sink->set_filter(flt::attr< int >("Severity") >= warning);

        // You can also manage backend in a thread-safe manner
        {
            sinks::synchronous_sink< sinks::text_ostream_backend >::locked_backend_ptr p = sink.locked_backend();
            p->add_stream(boost::make_shared< std::ofstream >("test.log"));
            p->set_formatter(fmt::ostrm << "Level: " << fmt::attr< int >("Severity") << "Message: " << fmt::message());
        } // the backend gets released here
    }


[endsect]

[section:async Asynchronous sink frontend]

    #include <boost/log/sinks/sink.hpp>

The frontend is implemented in the `asynchronous_sink` class template. Like synchronous one, asynchronous sink frontend provides a way of synchronizing access to the backend. All log records are passed to the backend in a dedicated thread, which makes it suitable for backends that may block for a considerable amount of time (network and other hardware device-related sinks, for example). The internal thread of the frontend is spawned on the frontend constructor and joined on its destructor (which implies that the frontend destruction may block). Aside from that, the frontend is similar to the `synchronous_sink` class template.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // Create a backend and initialize it with a stream
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));

        // Wrap it into the frontend and register in the core
        boost::shared_ptr< sinks::asynchronous_sink< sinks::text_ostream_backend > > sink(new sinks::asynchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);

        // You can manage filtering through the sink interface
        sink->set_filter(flt::attr< int >("Severity") >= warning);

        // You can also manage backend in a thread-safe manner
        {
            sinks::asynchronous_sink< sinks::text_ostream_backend >::locked_backend_ptr p = sink.locked_backend();
            p->add_stream(boost::make_shared< std::ofstream >("test.log"));
            p->set_formatter(fmt::ostrm << "Level: " << fmt::attr< int >("Severity") << "Message: " << fmt::message());
        } // the backend gets released here
    }

[endsect]

[endsect]


[section:sink_backends Sink Backends]

[section:text_ostream Text stream backend]

    #include <boost/log/sinks/text_ostream_backend.hpp>

The text output stream sink backend is the most generic backend provided by the library out of box. The backend is implemented in the `basic_text_ostream_backend` class template (`text_ostream_backend` and `wtext_ostream_backend` convenience typedefs provided for narrow and wide character support). It supports formatting log records into strings and putting into one or several streams. Each attached stream gets the same result of formatting, so if you need to format log records differently for different streams, you will need to create several sinks - each with its own formatter.

The sink backend is compatible with any stream that derives from the `std::basic_ostream` class template. However, the sink can provide additional information about written data if the stream object also publicly derives from `record_writer` interface class. This interface declares methods that are called by the backend before and after each record is put into the stream. These hints can be used by the stream implementation to delimit log records (for example, an XML-writing stream could insert tags and indentation between log records) or perform other actions aligned to log records (for example, rotate the file without cutting a log record in the middle).

The backend provides another feature that may come useful when debugging your application. With `auto_flush` method one can enable the sink to automatically flush buffers of all attached streams after each log record written. This will, of course, degrade logging performance, but in case of application crash there is a good probability that last log records are not lost.

    // The function registers text output sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // Create a backend and attach a couple of streams to it
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(&std::clog, logging::empty_deleter()));
        backend->add_stream(boost::shared_ptr< std::ostream >(new std::ofstream("test.log")));

        // Enable auto-flushing after each log record written
        backend->auto_flush(true);

        // Wrap it into the frontend and register in the core. The backend requires synchronization in the frontend.
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        core->add_sink(sink);
    }

[endsect]

[section:syslog Syslog backend]

    #include <boost/log/sinks/syslog_backend.hpp>

The syslog backend, as it comes from its name, provides support for syslog API that is available on virtually any UNIX or Linux platform. On Windows there is no  known implementation of the syslog API, therefore the backend is not available on this platform.

The backend is implemented in the `basic_syslog_backend` class template, `syslog_backend` and `wsyslog_backend` convenience typedefs are also available. The backend supports formatting log records, and therefore requires thread synchronization in the frontend. The backend also supports severity level translation from the application-specific values to the syslog-defined values. This is achieved with an additional function object, level extractor, that receives a set of attribute values of each log record and returns appropriate syslog level value. This value is used by the backend in the `LOG_MAKEPRI` macro to construct the final priority value of the syslog record. The other argument of the `LOG_MAKEPRI` macro, the facility, is constant for each backend object and can be specified in the backend constructor arguments.

Level extractors can be written by library users to map the application log levels to the syslog levels the best way. However, the library provides two extractors that would fit this need in obvious cases. The `straightforward_level_mapping` class template provides a way to directly map values of some integral attribute to syslog levels. The `level_mapping` class template adds some flexibility and allows to map arbitrary values of some integral attribute to syslog levels.

One additional thing should be noted. Syslog API allows to customize the service behavior by specifying additional flags to the `openlog` call. The backend too supports this feature - the options can be passed to the backend constructor. However, since `openlog` is only called once per logging session, the constructor argument is only taken into consideration for the first backend object being created.

Anyway, one example is better than a thousand words.

    // The function registers syslog sink in the logging library
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // Create a backend. Specify facility and options in the constructor.
        boost::shared_ptr< sinks::syslog_backend > backend(new sinks::syslog_backend(
            sinks::syslog::user, sinks::syslog::console_fallback | sinks::syslog::log_pid));

        // Set the straightforward level translator for the "Severity" attribute of type int
        backend->set_level_extractor(sinks::syslog::straightforward_level_mapping< char >("Severity"));

        // Wrap it into the frontend and register in the core. The backend requires synchronization in the frontend.
        boost::shared_ptr< sinks::synchronous_sink< sinks::syslog_backend > > sink(new sinks::synchronous_sink< sinks::syslog_backend >(backend));
        core->add_sink(sink);

        // Create a new backend. No use to specify options here.
        backend.reset(new sinks::syslog_backend(sinks::syslog::local0));

        // Create and fill in another level translator for "MyLevel" attribute of type string
        sinks::syslog::level_mapping< char, std::string > mapping("MyLevel");
        mapping["debug"] = sinks::syslog::debug;
        mapping["normal"] = sinks::syslog::info;
        mapping["warning"] = sinks::syslog::warning;
        mapping["failure"] = sinks::syslog::critical;
        backend->set_level_extractor(mapping);

        // Wrap it into the frontend and register in the core.
        sink.reset(new sinks::synchronous_sink< sinks::syslog_backend >(backend));
        core->add_sink(sink);
    }

Please note that all syslog constants, as well as level extractors, are declared within a nested namespace `syslog`. The library will not accept (and does not declare in the backend interface) native syslog constants, which are macros, actually.

[endsect]

[endsect]


[section:filters Filters]

As it was pointed out in [link log.tutorial.tutorial_5 tutorial], filters are implemented as Lambda-like expressions with placeholders for attribute values. This section will describe placeholders that can be used to build more complex expressions.

[section:has_attr Attribute presence filter]

    #include <boost/log/filters/has_attr.hpp>

The filter `has_attr` checks if an attribute value with specified name and, optionally, type is attached to a log record. If no type specified to the filter, the filter returns `true` if any-typed value with the specified name is found. If an MPL-compatible type sequence in specified as a value type, the filter returns `true` if a value with the specified name and one of the specified types is found.

This filter is usually used in conjunction with [link log.advanced.formatters.conditional conditional formatters], but it also can be used as a quick filter based on the log record structure. For example, one can use this filter to extract statistic records and route them to a specific sink.

    // A simple sink backend to accumulate statistic information
    class my_stat_accumulator :
        public sinks::basic_sink_backend< char, sinks::backend_synchronization_tag >
    {
        // A map of accumulated statistic values, ordered by the statistic information stream name
        std::map< std::string, int > m_StatInfo;

    public:
        // Destructor
        ~my_stat_accumulator()
        {
            // Display the accumulated data
            for (std::map< std::string, int >::const_iterator it = m_StatInfo.begin(); it != m_StatInfo.end(); ++it)
            {
                std::cout << "Statistic stream: " << it->first << ", accumulated value: " << it->second << "\n";
            }
            std::cout.flush();
        }

        // The method is called for every log record being put into the sink backend
        void write_message(values_view_type const& attributes, string_type const& message)
        {
            // First, acquire statistic information stream name
            values_view_type::const_iterator itName = attributes.find("StatisticStream");
            if (itName != attributes.end())
            {
                boost::optional< std::string const& > name = itName->second.get< std::string >();
                if (name)
                {
                    // Next, get the statistic value change
                    values_view_type::const_iterator itChange = attributes.find("Change");
                    if (itChange != attributes.end())
                    {
                        boost::optional< int const& > change = itChange->second.get< int >();
                        if (change)
                        {
                            // Accumulate the statistic data
                            m_StatInfo[name.get()] += change.get();
                        }
                    }
                }
            }
        }
    };

    // The function registers two sinks - one for statistic information, and another one for other records
    void foo()
    {
        boost::shared_ptr< logging_core > core = logging::logging_core::get();

        // Create a backend and attach a stream to it
        boost::shared_ptr< sinks::text_ostream_backend > backend(new sinks::text_ostream_backend);
        backend->add_stream(boost::shared_ptr< std::ostream >(new std::ofstream("test.log")));

        // Create a frontend and setup filtering
        boost::shared_ptr< sinks::synchronous_sink< sinks::text_ostream_backend > > sink(new sinks::synchronous_sink< sinks::text_ostream_backend >(backend));
        // All records that don't have a "StatisticStream" attribute attached will go to the "test.log" file
        sink->set_filter(!flt::has_attr("StatisticStream"));

        core->add_sink(sink);

        // Create another sink that will receive all statistic data
        boost::shared_ptr< sinks::synchronous_sink< my_stat_accumulator > > stat_sink(new sinks::synchronous_sink< my_stat_accumulator >);
        // All records with a "StatisticStream" string attribute attached will go to the my_stat_accumulator sink
        sink->set_filter(flt::has_attr< std::string >("StatisticStream"));

        core->add_sink(stat_sink);
    }

    // This simple macro will simplify putting statistic data into a logger
    #define PUT_STAT(lg, stat_stream, change)\
        if (true) {\
            BOOST_LOG_SCOPED_LOGGER_TAG(lg, "StatisticStream", std::string, stat_stream);\
            BOOST_LOG_SCOPED_LOGGER_TAG(lg, "Change", int, change);\
            BOOST_LOG(lg);\
        } else ((void)0)

    void bar()
    {
        src::logger lg;

        // Put a regular log record, it will go to the "test.log" file
        BOOST_LOG(lg) << "A regular log record";

        // Put some statistic data
        PUT_STAT(lg, "StreamOne", 10);
        PUT_STAT(lg, "StreamTwo", 20);
        PUT_STAT(lg, "StreamOne", -5);
    }

Please note that in the example above we extended the library in two ways: we defined a new sink backend `my_stat_accumulator` and a new macro `PUT_STAT`. Also note the technique of extracting attrubute value from the view - we need to both check that the needed attribute value is found in the view and that it has the needed type. There is also a mechanism of attribute value extractors that can simplify this, especially when an attribute can have a number of types. Refer to [link log.extension Extending the library] section for more details.

[endsect]

[section:attr Generic attribute placeholder]

    #include <boost/log/filters/attr.hpp>

Unlike `has_attr`, `attr` construct is not a complete filter by itself. Instead, it is a placeholder that may take part in a complete filter expressions like this:

    sink->set_filter(flt::attr< int >("Severity") >= 5 && flt::attr< std::string >("Channel") == "net");

The line above registers a composite filter that consists of two elementary subfilters: the first one checks the severity level, and the second checks the channel name. Like `has_attr`, the `attr` placeholder accepts an expected attribute value type or set of types in an MPL-compatible type sequence. However, attribute value type is not optional with `attr`, like it is with `has_attr`.

Besides generating lambda expressions, the `attr` placeholder allows to construct filters with its member functions. There are currently two such members that can be used with any type:

* `is_in_range(T const& lower, T const& upper)` generates a filter that returns `true` if the attribute value `x` of type `T` satisfies condition `lower <= x < upper`. For example:

    sink->set_filter(flt::attr< int >("Severity").is_in_range(3, 5)); // drops all records that have level below 3 or greater than 4

* `satisfies(FunT const& fun)` allows to inject a user-defined unary predicate `fun` into the filter. The preticate should accept an attribute value as an argument and return a value, convertible to boolean. The result of the filter will be equivalent to the result of the predicate. For example:

    bool check_severity_level(int level);

    sink->set_filter(flt::attr< int >("Severity").satisfies(&check_severity_level));

The `attr` placeholder has an advanced support for string-typed attribute values (that have type `std::string` or `std::wstring`, that is). For string attribute values there are also available the following member functions:

* `begins_with(T const& s)`, `ends_with(T const& s)` and `contains(T const& s)`. As follows from their names, the functions construct filters that rerurn `true` if an attribute value begins with, ends with or contains a specified substring, respectively. The string comparison is case sensitive.

    sink->set_filter(flt::attr< std::string >("Domain").ends_with(".ru")); // selects only records that are related to russian web domains

* `matches(T const& regex)` allows to set up a filter based on [@http://www.boost.org/doc/libs/release/libs/regex/doc/html/index.html Boost.Regex] regular expressions matching mechanism. The filter returns `true` if matching is successful.

    sink->set_filter(flt::attr< std::string >("Domain").matches("www\\..*\\.ru"));

[endsect]

[endsect]


[section:formatters Formatters]

[section:conditional Conditional formatters]

[endsect]

[endsect]


[section:attributes Attributes]

[section:named_scope Named scopes]

    #include <boost/log/attributes/named_scope.hpp>

The logging library supports mainaining scopes stack tracking during the application execution. This stack may either be written to log or be used for other needs (for example, to save the exact call sequence that led to and exception when throwing one). The attribute `named_scope` implements support for scope naming, one can register it the following way:

    logging::logging_core::get()->add_global_attribute(
        "Scope", boost::make_shared< attrs::named_scope >());

Now we can mark execution scopes with macros `BOOST_LOG_FUNCTION` and `BOOST_LOG_NAMED_SCOPE` (the latter accepts a string literal as an argument) like this:

    void foo(int n)
    {
        // Mark the scope of the function foo
        BOOST_LOG_FUNCTION();

        switch (n)
        {
        case 0:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 0");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        case 1:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("case 1");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;

        default:
            {
                // Mark the current scope
                BOOST_LOG_NAMED_SCOPE("default");
                BOOST_LOG(lg) << "Some log record";
                bar(); // call some function
            }
            break;
        }
    }

Later we will be able to see in log that the `bar` function was called from `foo` and, more precisely, from the case statement that corresponds the value of `n`. This may be very useful when tracking down subtle bugs that show only when `bar` is called from a specific location (e.g. if `bar` is being passed invalid arguments in that particular location).

Another good case is attaching the scope stack information to an exception. With help of Boost.Exception, this is possible:

    typedef boost::error_info< struct tag_scopes, attrs::named_scope > scopes_info;

    void bar(int x)
    {
        BOOST_LOG_FUNCTION();

        if (x < 0)
        {
            throw boost::enable_error_info(std::range_error("x must not be negative"))
                << scopes_info(attrs::named_scope::get_scopes());
        }
    }

    void foo()
    {
        BOOST_LOG_FUNCTION();

        try
        {
            bar(-1);
        }
        catch (std::range_error& e)
        {
            BOOST_LOG(lg) << "bar call failed: " << e.what() << ", scopes stack:\n"
                << *boost::get_error_info< scopes_info >(e);
        }
    }

[endsect]

[section:scoped_attributes Scoped attributes]

[endsect]

[endsect]

[endsect]


[section:extension Extending the library]

[section:sinks Writing your own sinks]

[endsect]

[section:sources Writing your own sources]

[endsect]

[section:attributes Writing your own attributes]

[endsect]

[endsect]

[xinclude autodoc.xml]

[section:acknowledgements Acknowledgements]

* Luca Rigini wrote the initial implementation of the NT event log sink and made a lot of suggestions on how to improve the library in regard of writing user-defined sinks.
* Jean-Daniel Michaud, Michael Lacher and all others who took part in the discussion of the requirements to the library on [@http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Boost.Logging Wiki].
* John Torjo, Gennadiy Rozental and others for their discussion on the John's logging library on the Boost developers list. It helped a lot to learn the requirements and possible solutions for the library.
* All authors of the great Boost libraries that were involved in this library (notably, Boost.SmartPtr, Boost.Thread, Boost.Function, Boost.Optional, Boost.DateTime, Boost.Filesystem, Boost.Intrusive, Boost.IOStreams and other).

[endsect]
